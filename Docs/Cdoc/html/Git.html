<!-- Git.html -->
<!-- Created by Carol Clark on 24 Aug 2011 for project Support. -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Git</title>
	<link rel="stylesheet" type="text/css" href="../css/technical.css" />
</head>
<body>
<!-- @navhead "Support.html" "Support" "History_Support.html" -->
<h1>Git</h1>

<!-- @topicList "Git" "Contents" -->
	<!-- @topicGroup "Workflows" "1" -->
	<!-- @topicItem "AppCode with Waffle" "#WorkflowAppCode" "0" "current workflow" -->
		<!-- @topicItem "Workflow Subtasks" "#workflowSubtasks" "1" "common subtasks" -->
	<!-- @topicItem "Xcode with Git" "#WorkflowXcode" "0" "previous workflow" -->
	<!-- @topicGroup "" "5" -->
	<!-- @topicItem "Git Tasks" "#GitTasks_" "0" "" -->
	<!-- @topicItem "Managing Repositories" "#ManagingRepositories" "0" "" -->
	<!-- @topicItem "Policies and Notes" "#GitPolicies_" "0" "" -->
<!-- @/topicList -->

<!-- @marker "Workflows" -->
<h2>Workflows</h2>

<div style="page-break-before: always">
	<h3 id="WorkflowAppCode">Workflow: AppCode with Waffle</h3><div style="background-color: #d8e8ff">
		<h4>While Issue Not Complete</h4>
			<h5>Create Task</h5><ul>
				<li class="blurb">for release branch, see <a href="#adminReleaseBranch"><span class='em'>Release Branch</span></a></li>
				<li><strong>Update Branch from Master:</strong><ul>
					<li>master branch; update project; if changed: [test master, merge to branch, test branch]; commit</li>
				</ul></li>
				<li>create new task with #&lt;issueID&gt; at end of name<ul>
					<li>in dialog: check base branch; add issue number to end of branch name</li>
				</ul></li>
				<li>push branch</li></ul>
			<h5>While Task(s) Not Complete</h5><div class='indent'>
				<p><b>Select Task</b></p><ul>
					<li>switch to task; merge in master branch</li>
					<li>check for applicable stashes; apply as indicated</li>
					<li>commit</li></ul>
				<p><b>Develop:</b> repeat to commit: edit/test; refresh; status; diff modifications; add/stage</p>
				<p><b>Commit</b></p><ul>
					<li>refresh; add unversioned and/or other files as indicated; check for stray spaces (`gdcc`)</li>
					<li>backup GitHub, AppCode content</li>
					<li>diff all files in changelist; update message; commit</li>
				</ul>
				<p><b>Publish</b></p><ul>
					<li>push to remote tracking branch</li>
					<li>switch to local master; merge branch; test</li>
				</ul></div>
				<p class="indent"><b>If Task Complete:</b> delete Task and local branch</p>
		<h4>Issue Tasks Complete: To Review</h4><ul>
			<li><strong>Update Branch from Master</strong></li>
			<li>on local master branch, run all tests</li>
			<li>issue GitHub pull request against master<ul>
				<li>title: may add (close | fix | resolve) #&lt;ID&gt; and/or connect #&lt;ID&gt;</li>
			</ul></li>
		</ul>
		<h4>Issue Review Complete: Close Issue</h4><ul>
			<li>associated pull request: verify automatic merge available; merge; [resolve merge conflicts, if any; retest]</li>
			<li>pull master</li>
		</ul>

		<h5>[Archive Repository]</h5>
	</div>
</div>

<div style="page-break-before: always">
	<h5 id="workflowSubtasks">Workflow: Administrator Subtasks</h5><div style="background-color: #ecf4ff">
	<!-- @marker "adminReleaseBranch" -->
	<h6>Morning/Working Report</h6><ul>
	<li>branch list; status; set $cb to current branch; show --name-only</li>
	<li>for master.$cb, origin/master.master, master.origin/master: lg; diff --name-status</li>
	<li>branch unmerged master; stash list</li>
</ul>

	<h6 id='adminCompareRevisions'>Compare Revisions</h6><ul>
	<li><span class='em'>Compare</span>: (<span class='mono'>difftool --name-status first..second; lg first..second</span>)</li>
</ul>

	<h6 id='adminCompareAncestry'>Compare Ancestry</h6><ul>
	<li><span class='em'>Ancestry</span>: (<span class='mono'>difftool --name-status first...second; lg first..second</span>)</li>
	<li class='ital'>difference between Compare Revisions and Compare Ancestry is the extra dot in difftool for Ancestry</li>
</ul>

	<h6 id='adminReleaseBranch'>Release Branch</h6>
	<p class='blurb'>for branching strategy, see <a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a></p><ul>
	<li>select version number (eg. "1.0"); set $vn; create branch release-$vn</li>
	<li>bump version: make changes to code and resources to match new version number</li>
	<li>commit ("bump version to $vn")</li>
	<li>bug fixes as indicated</li>
	<li>update history files, issue milestones</li>
	<li>merge release branch into 'production'; tag "revision-$vn"; push to 'production'; push tags</li>
	<li>merge release branch into 'master'; push 'master'; delete release branch</li>
</ul>

	<!-- @marker "adminResolveConflicts" -->
	<h6 id='adminResolveConflicts'>Resolve Conflicts</h6><ul>
	<li>status</li>
	<li>if conflicts: <span class='mono'>merge resolve</span> (mergetool), saving successfully merged files<ul>
		<li>to choose one file, use <span class='mono'>checkout --[ours | theirs]</span> for local or merge target, respectively</li>
	</ul></li>
	<li class='ital'>if fetchup merge fails, could try: <span class='mono'>git rebase --preserve-merges @{u}</span></li>
	<li><span class='mono'>commit / resolve merge</span></li>
	<li>OR to undo merge: <span class='mono'>git merge --abort</span></li>
	<li>to recover corrupted project file: close in Xcode; diff fileMerge with previous good copy; edit manually</li>
</ul>

	<!-- @marker "adminFixDivergentBranches" -->
	<h6 id='adminFixDivergentBranches'>Fix Divergent Branches</h6><ul>
	<li>use 'git rebase'</li>
</ul>
</div></div>

<div style="page-break-before: always">
	<h4 id="WorkflowXcode">Workflow: Xcode with Git</h4><div style="background-color: #ffebcd">
	<h5>Branch</h5><ul>
		<li>if current branch is uncommitted, commit or stash</li>
		<li><span class='em'>Update Master:</span>	<ul>
			<li>checkout master; verify status clean</li>
			<li>fetch updates (<span class='mono'>git remote update --prune</span>); status</li>
			<li>if changed: merge updateMaster (<span class='mono'>git merge --ff-only @{u}</span>); <a href="#adminResolveConflicts"><span class='em'>Resolve Conflicts</span></a>; test; push</li>
		</ul></li>
		<li>checkout branch<ul>
			<li>pre-existing branch<ul>
				<li><a href="#tsk_MergeMaster">Merge Master</a></li>
				<li>recover any stashes</li>
			</ul></li>
			<li>OR new branch<ul>
				<li>checkout new branch; set $cb; <span class='mono'>git push --set-upstream origin $cb</span></li>
			</ul></li>
			<li>OR create <a href="#adminReleaseBranch"><span class='em'>Release Branch</span></a> as indicated</li>
		</ul></li>
		<li>create new bot(s) '&lt;targetName&gt; &lt;branchName&gt;'</li>
	</ul>
		<h5>Repeat</h5><div class='indent'>
		<p><b>Develop:</b> repeat until ready to commit: edit/test; status; verify modifications (diff); [add/stage]</p>
		<p><b>Commit</b></p><ul>
		<li>construct and save commit message; verify modifications (diff --cached); test</li>
		<li>status: check branch; get $cb; add / review files to be committed; review commit msgfile and #issue</li>
		<li>check for stray spaces (diff --cached --check); [backup GitHub issues; add, OR if failure checkout original]</li>
		<li>status; update and repeat if indicated; commit msgfile</li>
		<li>status; show; <a href="#adminCompareRevisions"><span class='em'>Compare</span></a> origin.$cb; [to amend: reset --soft lastCommit]</li>
		<li>check stash list</li>
		<li><span class='em'>Update Master</span>; <span class='em'>Merge Master</span>; checkout $cb</li>
	</ul>
		<p><b>Publish</b></p><ul>
		<li>status; verify branch; show --name-only; <a href="#adminCompareRevisions"><span class='em'>Compare</span></a> origin/$cb.$cb; push</li>
	</ul>
	</div>
		<h5>Put Away Branch</h5><div class='indent'>
		<p><b>Merge to (Master)</b> (or another parent branch)</p><ul>
		<li>run all tests; from branch to be merged: check for status clear; set 'current branch' variable </li>
		<li>checkout master; check for unmerged branches; show; <a href="#adminCompareRevisions"><span class='em'>Compare</span></a> master.$cb</li>
		<li><span class='mono'>getMergeMessage</span>; <span class='mono'>merge 'from branch' (--no-ff -m "$mm" &lt;branch[$cb]&gt;</span>)</li>
		<li>status; <a href="#adminResolveConflicts"><span class='em'>Resolve Conflicts</span></a>; [retest]</li>
		<li>show; lg; <a href="#adminCompareRevisions"><span class='em'>Compare</span></a> origin.master; push; status</li>
		<li>for each local branch other than master and $cb: <span class='em'>Merge Master</span></li>
		<li>checkout $cb; push; [checkout master; delete local branch]; (manage remote stale branches periodically from GitHub)</li>
	</ul>
	<p><b>[Archive Repository]</b></p>
</div></div></div>

<!-- @marker "Git Tasks" -->
<div style="page-break-before: always">
<h2>Git Tasks</h2>
</div>
<!-- @topicList "Git Tasks" "GitTasks_" -->
	<!-- @topicItem "Branch" "#tsk_Branch" "1" "" -->
	<!-- @topicItem "Master Branch" "#tsk_MasterBranch" "1" "" -->
	<!-- @topicItem "Stash" "#tsk_Stash" "1" "" -->
	<!-- @topicItem "Diff" "#tsk_Diff" "1" "" -->
	<!-- @topicItem "Tag" "#tsk_Tag" "1" "" -->
	<!-- @topicItem "Bisect" "#tsk_Bisect" "1" "" -->
	<!-- @topicItem "Information" "#tsk_Information" "1" "" -->
	<!-- @topicItem "Undo" "#tsk_Undo" "1" "" -->
	<!-- @topicItem "Fix Line Endings" "#tsk_FixLineEndings" "1" "" -->
<!-- @/topicList -->

<!-- @marker "Branch" -->
<h4 id="tsk_Branch">Branch</h4><ul>
	<li><span class='mono'>git branch</span>&nbsp;&nbsp;# to list current branches<ul>
		<li><span class='mono'>--remotes</span>&nbsp;&nbsp;# to list remote branches</li>
		<li><span class='mono'>--all</span>&nbsp;&nbsp;# to list both local and remote branches</li>
		<li><span class='mono'>--no-merged</span>&nbsp;&nbsp;# check for unmerged branches</li>
		<li><span class='mono'>--move [&lt;oldbranch&gt;] &lt;newbranch&gt;</span>&nbsp;&nbsp;# to rename a branch<ul>
			<li>then, to rename remote branch to match:<ul>
				<li class='blurb'>this assumes remote branch is named 'origin'; can use <span class='mono'>git remote -v</span> to verify</li>
				<li><span class='mono'>git push origin :&lt;oldBranch&gt;&nbsp;&nbsp;# delete old remote branch</span></li>
				<li><span class='mono'>git push --set-upstream origin &lt;newBranch&gt;&nbsp;&nbsp;# recreate remote branch with new name</span></li>
			</ul>
		</li>
		</ul></li>
		<li><span class='mono'>--delete &lt;branchname&gt;</span>&nbsp;&nbsp;# delete a branch<ul>
			<li class='blurb'>also see git docs for information about deleting and cleaning up remote branches</li>
		</ul></li>
	</ul></li>
	<li><span class='mono'>git checkout -b &lt;new-branch&gt; [&lt;start_point&gt;]</span>&nbsp;&nbsp;# move existing work to a new branch, rooted at commit &lt;start_point&gt; if specified</li>
</ul>

<!-- @marker "Master Branch" -->
<h4 id="tsk_MasterBranch">Master Branch</h4>
	<h5><a id="tsk_MergeMaster">Merge Master</a></h5><ul>
		<li class="blurb">used with Xcode; otherwise, AppCode's own merge is used</li>
		<li>checkout branch; set $cb; show --name-status; <a href="#adminCompareAncestry"><span class='em'>Ancestry</span></a> $cb.master</li>
		<li>if changed:<ul>
			<li>merge mergeMaster <span class='mono'>(--no-ff -m "merge master")</span>; status; <a href="#adminResolveConflicts"><span class='em'>Resolve Conflicts</span></a></li>
			<li>test; show; <a href="#adminCompareRevisions"><span class='em'>Compare</span></a> origin/$cb.$cb; push</li>
		</ul></li>
	</ul>

	<h5><a id="tsk_UpdateMaster">Update Master</a></h5><ul>
		<li class="blurb">not needed for now; purpose is to update our code with work from others</li>
		<li>checkout master; verify status clean</li>
		<li>fetch updates (<span class='mono'>git remote update --prune</span>); status</li>
		<li>if changed: merge updateMaster (<span class='mono'>git merge --ff-only @{u}</span>)</li>
		<li><a href="#adminResolveConflicts"><span class='em'>Resolve Conflicts</span></a>; test; push</li>
	</ul>

<!-- @marker "Stash" -->
<h4 id="tsk_Stash">Stash</h4><ul>
	<li><span class='mono'>git stash save &lt;name&gt;</span>&nbsp;&nbsp;# save stash named &lt;name&gt;; leave working directory clean<ul>
			<li><span class='mono'>add --keep-index</span>&nbsp;&nbsp;# to leave all changes already added to the index intact</li>
	</ul></li>
	<li>apply:<ul>
		<li><span class='mono'>git stash apply</span>&nbsp;&nbsp;# to apply the top stash to the current working copy</li>
		<li><span class='mono'>git stash branch</span>&nbsp;&nbsp;# to apply the top stash to a new branch based in the stash's base revision</li>
		<li>add <span class='mono'>stash@{&lt;index&gt;}</span>&nbsp;&nbsp;#  to specify a different stash</li>
	</ul></li>
	<li><span class='mono'>git stash list</span>&nbsp;&nbsp;# list all stashes in repository</li>
	<li><span class='mono'>git stash drop</span>&nbsp;&nbsp;# remove the specified stash</li>
	<li><span class='mono'>git stash show [stash@{n}]</span>&nbsp;&nbsp;# show details for the top or a specified stash</li>
</ul>

<p><br /><br /><br /><br /><br /></p>
<!-- @marker "Diff" -->
<h4 id="tsk_Diff">Diff</h4>
	<h5>Diff Commands</h5><ul>
		<li><span class='mono'>git diff</span>&nbsp;&nbsp;# working copy and index (unstaged)</li>
		<li><span class='mono'>git diff --cached</span>&nbsp;&nbsp;# index and last commit (staged)</li>
		<li><span class='mono'>git diff HEAD</span>&nbsp;&nbsp;# working directory since your last commit (unstaged and staged)</li>
		<li><span class='mono'>git diff &lt;branch&gt;</span>&nbsp;&nbsp;# working copy and another branch</li>
		<li><span class='mono'>git diff &lt;branch1&gt;..&lt;branch2&gt;</span>&nbsp;&nbsp;# tips of the two branches</li>
		<li><span class='mono'>git diff &lt;branch1&gt;...&lt;branch2&gt;</span>&nbsp;&nbsp;# from their common ancestor to branch</li>
		<li><span class='mono'>git difftool &lt;arguments as above&gt;</span>&nbsp;&nbsp;# display results using FileMerge</li>
	</ul>
	<h5>Diff Options</h5><ul>
		<li><span class='mono'>-- ./path</span>&nbsp;&nbsp;# restrict to a path</li>
		<li><span class='mono'>--name-status</span>&nbsp;&nbsp;# one line per file (like svn status)</li>
		<li><span class='mono'>--pretty=oneline</span>&nbsp;&nbsp;# to show just sha and one-line comment</li>
		<li><span class='mono'>--graph</span>&nbsp;&nbsp;#  to show branch relationships<ul>
			<li>with <span class='mono'>--topo-order</span>&nbsp;&nbsp;# shows top-down so tree is clearer</li>
		</ul></li>
		<li><span class='mono'>--date-order</span>&nbsp;&nbsp;# to show chronologically</li>
	</ul>
	<h5>diff a previous version of a file</h5><ul>
		<li><span class='mono'>git lg --follow &lt;filename&gt;</span>&nbsp;&nbsp;# show changes to this file</li>
		<li><span class='mono'>st=&lt;shaTag&gt;</span>&nbsp;&nbsp;# set tag to target sha</li>
		<li><span class='mono'>git show --name-only &lt;shaTag&gt; </span>&nbsp;&nbsp;# see commit message; get file path<ul>
			<li>if file path is the same as current path:<ul>
				<li><span class='mono'>git difftool &lt;shaTag&gt; &lt;filename&gt;</span>&nbsp;&nbsp;# diff revisions</li>
			</ul></li>
			<li>else<ul>
				<li><span class='mono'>git checkout &lt;shaTag&gt; &lt;filename&gt;</span>&nbsp;&nbsp;# checkout file to compare</li>
				<li>use BBEdit to compare files</li>
			</ul></li>
		</ul></li>
	</ul>

<!-- @marker "Tag" -->
<h4 id="tsk_Tag">Tag</h4><ul>
	<li><span class='mono'>git tag</span>&nbsp;&nbsp;# list<ul>
		<li><span class='mono'>-l</span>&nbsp;&nbsp;# to match a pattern</li>
	</ul></li>
	<li><span class='mono'>git tag -a &lt;tag&gt; -m '&lt;msg&gt;'</span>&nbsp;&nbsp;# create</li>
	<li><span class='mono'>git tag -d &lt;tag&gt;</span>&nbsp;&nbsp;# delete</li>
	<li><span class='mono'>git show &lt;tag&gt;</span>&nbsp;&nbsp;# show information about &lt;tag&gt;</li>
	<li><span class='mono'>git push --tags</span>&nbsp;&nbsp;# push tags</li>
</ul>

<!-- @marker "Bisect" -->
<h4 id='tsk_Bisect'>Bisect</h4><ul>
	<li><span class='mono'>git checkout -b &lt;newbranch&gt;</span>&nbsp;&nbsp;# checkout a new branch<ul>
		<li><b>Detached Head</b><ul>
			<li>If accidentally done from the master branch, a detached head is possible. Correct by checking the work out into  new branch, which restores master to its previous state.</li>
		</ul></li>
	</ul></li>
	<li><span class='mono'>git bisect start</span>&nbsp;&nbsp;# start a bisect operation<ul>
		<li class='blurb'>then execute <span class='mono'>good</span> and <span class='mono'>bad</span> to establish range</li>
	</ul></li>
	<li><span class='mono'>git bisect bad</span>&nbsp;&nbsp;# mark current bisect commit as bad</li>
	<li><span class='mono'>git bisect good</span>&nbsp;&nbsp;# mark current bisect commit as good</li>
	<li><span class='mono'>git bisect skip</span>&nbsp;&nbsp;# skip current bisect commit</li>
	<li><span class='mono'>git bisect reset</span>&nbsp;&nbsp;# clean up from a bisection</li>
	<li><span class='mono'>git bisect log</span>&nbsp;&nbsp;# show log of current bisection</li>
	<li><span class='mono'>git bisect replay</span>&nbsp;&nbsp; &lt;logfile&gt; # replay bisection from edited log output &lt;logfile&gt;</li>
</ul>

<!-- @marker "Information" -->
<h4 id="tsk_Information">Information</h4>
	<h5>Log Commands</h5><ul>
		<li><span class='mono'>git log &lt;tag&gt;..</span>&nbsp;&nbsp;# commits since (not reachable from) &lt;tag&gt;</li>
		<li><span class='mono'>git log &lt;branch&gt;..master</span>&nbsp;&nbsp;# commits reachable from master but not &lt;branch&gt;</li>
		<li><span class='mono'>git log master..&lt;branch&gt;</span>&nbsp;&nbsp;# commits reachable from &lt;branch&gt; but not master</li>
		<li><span class='mono'>git log master...&lt;branch&gt;</span>&nbsp;&nbsp;# commits reachable from either &lt;branch&gt; or master, but not both</li>
		<li><span class='mono'>git log &lt;folder&gt;/</span>&nbsp;&nbsp;# commits that modify any file under &lt;folder&gt;/</li>
		<li><span class='mono'>git lg</span>&nbsp;&nbsp;# in-house alias to display single-line log output</li>
	</ul>
	<h5>Log Options</h5><ul>
		<li><span class='mono'>git log --since="2 weeks ago"</span>&nbsp;&nbsp;# commits from the last 2 weeks</li>
		<li><span class='mono'>git log &lt;filename&gt;</span>&nbsp;&nbsp;# commits that modify &lt;filename&gt;</li>
		<li><span class='mono'>git log -S'&lt;pattern&gt;'</span>&nbsp;&nbsp;# commits that add or remove any file data matching the string '&lt;pattern&gt;'</li>
		<li><span class='mono'>git log --no-merges</span>&nbsp;&nbsp;# skip merge commits</li>
		<li><span class='mono'>git log --follow</span>&nbsp;&nbsp;# follow file through renames if any</li>
	</ul>
	<h5>Other Information Commands</h5><ul>
		<li><span class='mono'>git ls-files --other --exclude-standard</span>&nbsp;&nbsp;# untracked files</li>
		<li><span class='mono'>git branch --no-merged</span>&nbsp;&nbsp;# check for unmerged branches</li>
		<li><span class='mono'>git reflog [log options | with dates(custom)]</span>&nbsp;&nbsp;# show reflog</li>
	</ul>

<!-- @marker "Undo" -->
<h4 id="tsk_Undo">Undo</h4><ul>
	<li><span class='mono'>git checkout -- &lt;file&gt;</span>&nbsp;&nbsp;# restore one file to version in index</li>
	<li><span class='mono'>git checkout HEAD &lt;file&gt;</span>&nbsp;&nbsp;# restore one file to version in HEAD revision</li>
	<li><span class='mono'>git reset --soft HEAD@{1}</span>&nbsp;&nbsp;# undo last commit (set HEAD to point to parent of HEAD)</li>
	<li><span class='mono'>git reset --mixed HEAD@{1} (default)</span>&nbsp;&nbsp;# also update index to match new HEAD; same as unstaging everything</li>
	<li><span class='mono'>git reset --hard HEAD</span>&nbsp;&nbsp;# discard all changes since last commit; restores index and files (causes the results of "git diff" and "git diff --cached" to both be empty)</li>
	<li><span class='mono'>git revert [HEAD|&lt;commit&gt;]</span>&nbsp;&nbsp;# creates a new commit that undoes the most recent or a previous commit</li>
	<li><span class='mono'>git reflog; git checkout &lt;sha&gt;; git checkout -b &lt;branch&gt;</span> find and restore recently deleted branch</li>
</ul>

<!-- @marker "Fix Line Endings" -->
<h4 id='tsk_FixLineEndings'>Fix Line Endings</h4><ul>
	<li class='blurb'>for fixing line endings when adding files from an external source<ul>
		<li>see <a href="http://help.github.com/articles/dealing-with-line-endings/">GitHub: Dealing With Line Endings</a></li>
		<li>We used a slightly modified version of this technique when importing the pyparser script and its support. It seems to have worked fine, although after the reset step there were no files to add, and we were done.</li>
		<li>These steps show what we actually planned/did.</li>
	</ul></li>
	<li>checkin the files</li>
	<li>remove files from working tree and index: <span class='mono'>git rm --cached -r &lt;pathnames, eg. fldr/*&gt;</span></li>
	<li>rewrite the files back, with corrected line endings: <span class='mono'>git reset --hard</span></li>
	<li>if necessary:<ul>
		<li>add the files back into the index: <span class='mono'>git add --all</span><ul>
			<li class='blurb'>messages "warning: CRLF will be replaced by LF in file." are ok</li>
		</ul></li>
		<li><span class='mono'>git commit -m "normalize line endings"</span></li>
	</ul></li>
</ul>

<!-- @marker "Managing Repositories" -->
<h2>Managing Repositories</h2>
<!-- @topicList "Managing Repositories" "ManagingRepositories" -->
	<!-- @topicItem "Create Bare Repository" "#tsk_CreateBareRepository" "1" "" -->
	<!-- @topicItem "Fetch Working Copy of Repository" "#FetchWorkingCopy" "1" "" -->
	<!-- @topicItem "Create New Repository" "#tsk_CreateNewRepository" "1" "" -->
	<!-- @topicItem "Add Remote Repository" "#tsk_AddRemoteRepository" "1" "" -->
	<!-- @topicItem "Set Up User SSH" "#setupSSH" "1" "" -->
	<!-- @topicItem "Add User to ProjectLocker Account" "#AddPLUser" "1" "" -->
	<!-- @topicGroup "" "7" -->
<!-- @/topicList -->

<!-- @marker "Create Bare Repository" -->
<h4 id='tsk_CreateBareRepository'>Create Bare Repository</h4><ul>
	<li><span class='mono'>path=&lt;Repository&gt;</span> (eg. ~/Dev/gitrep/&lt;ProjectName&gt;; https://&lt;username&gt;@candcsoft.com/gitrep/&lt;ProjectName&gt;Remote)</li>
	<li class='mono'>mkdir -p ${path}; cd ${path}</li>
	<li class='mono'>git init --bare</li>
</ul>

<!-- @marker "Fetch Working Copy of Repository" -->
<h4 id='FetchWorkingCopy'>Fetch Working Copy of Repository</h4><ul>
	<li>Xcode: add working copy of git repository: Repositories &gt; Add Repository &gt; Clone<ul>
		<li><b>source repository:</b>~/Dev/gitrep/&lt;ProjectName&gt; or git-CCSoftware@pl5.projectLocker.com:&lt;ProjectName&gt;.git (or ssh://git-CCSoftware@pl5.projectLocker.com/&lt;ProjectName&gt;.git)</li>
		<li><b>name:</b> &lt;ProjectName&gt;</li>
		<li><b>save at:</b> ~/Dev/&lt;ProjectName&gt;</li>
	</ul></li>
</ul>

<!-- @marker "Create New Repository" -->
<h4 id='tsk_CreateNewRepository'>Create New Repository</h4><ul>
	<li>create an empty local or ProjectLocker repository<ul>
		<li>local: <a href="#tsk_CreateBareRepository">Create Bare Repository</a> at ~/Dev/gitrep/&lt;ProjectName&gt;</li>
		<li>ProjectLocker: add project to ProjectLocker account</li>
	</ul></li>
	<li>Xcode: <a href="#FetchWorkingCopy">Fetch Working Copy of Repository</a></li>
	<li class='blurb'>Xcode can clone this empty repository, but does not interact normally with it yet.</li>
	<li>add new or existing content<ul>
		<li>in working copy, either add existing files or create new ones (eg. Xcode workspace and initial history file Cdoc/History_&lt;ProjectName&gt;.html)</li>
		<li>Terminal: <span class='mono'>cd ~/Dev/&lt;ProjectName&gt;; git add <span class='depr'>--all</span> --interactive</span></li>
		<li>Xcode: commit; push</li>
	</ul></li>
</ul>

<!-- @marker "Add Remote Repository" -->
<h4 id="tsk_AddRemoteRepository">Add Remote Repository</h4><ul class='depr'>
	<li class='blurb'>Add Remote Repository from existing working copy ~/Dev/&lt;ProjectName&gt;</li>
	<li>add repository to ProjectLocker account</li>
	<li>push working copy's master branch to remote/master (create)</li>
</ul>
<ul>
	<li>remote addresses: https://carolclark@github.com/carolclark/Punkin.git; https://github.com/lauracello/Punkin</li>
</ul>

<!-- @marker "Set Up User SSH" -->
<h4 id='setupSSH'>Set Up User SSH</h4><ul>
	<li>on User's computer, login to user account</li>
	<li>Terminal:<ul>
		<li><span class='mono'>ssh-keygen -t rsa</span>: create public and private ssh identity keys @ ~/.ssh; establish passphrase</li>
		<li><span class='mono'>cd ~/.ssh; cp id_rsa.pub authorized_keys</span>: create ~/.ssh/authorized_keys file containing public key</li>
	</ul></li>
</ul>

<!-- @marker "Add User to ProjectLocker Account" -->
<h4 id='AddPLUser'>Add User to ProjectLocker Account</h4><ul>
	<li>ProjectLocker admin: add user to account (List Account Users)</li>
	<li>User<ul>
		<li><a href="#setupSSH">User: Set Up User SSH</a></li>
		<li>copy the contents (without the carriage return at the end) of the file ${HOME}/.ssh/authorized_keys to the clipboard</li>
		<li>login to <a href="https://portal.projectlocker.com/">ProjectLocker</a> with your username and our password</li>
		<li>select Manage Public Keys; click Edit next to the account with your name</li>
		<li>paste the contents of the clipboard into the large field labeled Key</li>
		<li>At the end of the new key field is some text starting with &lt;username&gt;@. Copy from username to the end of the field into the User Name field.</li>
		<li>click Save Public Key</li>
	</ul></li>
</ul>

<!-- @marker "Policies and Notes" -->
<h2>Policies and Notes</h2>
<!-- @topicList "Policies and Notes" "GitPolicies_" -->
<!-- @/topicList -->

<ul>
	<li>do not use squash merges; rebase only to rebase an existing branch on more current code <span class='dq'>or clean up a current, unmerged branch</span>; see <a href="http://paul.stadig.name/2010/12/thou-shalt-not-lie-git-rebase-ammend.html">Paul Stadig: Thou Shalt Not Lie</a></li>
	<li class='dq'>sha/date marker: used in history and thread files to support matching history with repository<ul>
		<li>Setting the sha/date marker replaces the clearly-visible (from source code) commit message and notes with the sha/date marker. A branch's sha/date is often updated from another branch.</li>
		<li><span class='mono'>print "[$(cd /Users/carolclark/Dev/${proj}; git log -1 --pretty=format:'%h') $(date +%m/%d/20%y) &lt;placeholder&gt;]"</span></li>
	</ul></li>
</ul>

<p>
config, admin only: git remote add remote /Volumes/carollclark/gitrep/PunkinRemote	# adds PunkinRemote as remote "remote"
to replace an existing working copy with a newly-cloned one, first remove the existing repository from Xcode's repository list, close the Xcode workspace, and quit Terminal (BBEdit project?)<br />
my working copy has a branch for Laura's stuff (she pushes to Remote; I integrate and push to Main)<br />
internal: threads; branches; compound (here or with source control?)<br />
git diff master origin/master (same as master..origin/master?)<br />
see git-rev-parse<br />
see <a href="http://grit.rubyforge.org/">grit</a> for ruby scripting<br />
</p>

<hr class='footer' />
<p class='footer'>Copyright 2011-16 by C &amp; C Software, Inc. All rights reserved.</p>
<p class='footer'>Confidential and Proprietary.</p>
</body>
</html>
