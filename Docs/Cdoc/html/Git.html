<!-- Git.html -->
<!-- Created by Carol Clark on 24 Aug 2011 for project Support. -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Git</title>
	<link rel="stylesheet" type="text/css" href="../css/technical.css" />
	<style type="text/css">
		/* workflow borders; provide color to help developer keep place in workflow */
		h3.wf-feature {
			color: blue;
		}
		div.wf-feature {
			border: 12px none blue;border-right-style: solid;
		}
		h3.wf-hotfix {
			color: deeppink;
		}
		div.wf-hotfix {
			border: 12px none deeppink;border-right-style: solid;
		}
		div.wf-openTask {
			border: 8px none lightgreen;border-left-style: solid;
		}
		div.wf-createRelease {
			border: 8px none burlywood;border-left-style: solid;
		}
		div.wf-developCommit {
			border: 8px none green;border-left-style: solid;
		}
		div.wf-publish {
			border: 8px none orange;border-left-style: solid;
		}
		div.wf-mergeReview {
			border: 8px none mediumpurple;border-left-style: solid;
		}
		div.wf-triggerReview {
			border: 8px none mediumpurple;border-left-style: solid;
		}
		div.wf-close {
			border: 8px none purple;border-left-style: solid;
		}
		/* links: highlight tagged steps (top of Branch Workflow) and their links */
		.step {
			color: saddlebrown;
			font-weight: bold;
		}
		.step a:link {
			color: sienna;
		}
		.step a:hover {
			color: maroon;
		}
		.step a:visited {
			color: darkgoldenrod;
		}
		.step a:active {
			color: gold;
		}
		</style>
</head>
<body>
<!-- @navhead "DevSupport.html" "DevSupport" "History_Support.html" -->
<h1>Git</h1>

<!-- @topicList "Git" "Contents" -->
	<!-- @topicItem "Branches and Releases" "#Branches_Releases_" "0" "" -->
	<!-- @topicItem "Daily Workflows: AppCode with Waffle" "#WorkflowAppCode" "0" "current workflow" -->
		<!-- @topicItem "Feature Branches" "#Feature_Branch_Workflow_" "1" "" -->
		<!-- @topicItem "Release and Hotfix Branches" "#Release_Hotfix_Workflow_" "1" "" -->
		<!-- @topicItem "Workflow Subtasks" "#workflowSubtasks" "1" "" -->
	<!-- @topicGroup "" "6" -->
	<!-- @topicItem "Git Tasks" "#GitTasks_" "0" "" -->
	<!-- @topicItem "References" "#_References" "0" "" -->
	<!-- @topicItem "Notes" "#GitNotes_" "0" "" -->
<!-- @/topicList -->

<!-- @marker "Branches and Releases" -->
<h2>Branches and Releases</h2>
<!-- @topicList "Branches and Releases" "Branches_Releases_" -->
	<!-- @topicItem "Feature Branches" "#FeatureBranches_" "0" "" -->
	<!-- @topicItem "Release Branches" "#ReleaseBranches_" "0" "" -->
	<!-- @topicItem "Hotfix Branches" "#Hotfix_Branches_" "0" "" -->
<!-- @/topicList -->

<div class="paragraphs">
	<p>Repositories are hosted at GitHub. Work is organized around GitHub issues.
	YouTrack Epic issues with swimlanes group other issues into larger goals.</p>
	<p>Tasks are a fundamental element in our workflow. AppCode, our primary IDE, supports Tasks, each normally associated with a YouTrack task.</p>
	<p>YouTrack Agile boards, one each for backlog refinement and for development, help us to organize our work on epics, features and tasks.</p>
	<p>AppCode projects are dependent on Xcode's project format, so projects in Objective-C/C++ are first created in Xcode.</p>
</div>

<!-- @marker "Feature Branches" -->
<h4 id='FeatureBranches_'>Feature Branches</h4>
<p><strong>Naming Convention</strong>: &lt;task&gt;-#&lt;issueNum&gt;</p>

<div class="paragraphs">
	<p>Feature branches are used to develop features for a future release.
		A feature branch is created from master, and merged back, if successful, to master.</p>
	<p>In addition to standard feature branches, we also have some branches identified as "ongoing".
		Currently, there are such branches for documentation and AppCode configuration in each repository,<br />
		and an Accessor branch for Slate editing.</p>
</div>
<div class="paragraphs"> <p><a href="#WorkflowAppCode">Workflow: AppCode with Waffle</a> describes our prodecures for handling of feature branches.</p>
</div>

<p id="BranchingDiagram">Feature, release, and hotfix branches are all represented in this diagram:</p>
<div><img src="_img/GitBranchingModel.001.png" alt="Git Branching Model" style="width:600px;height:800px;" /></div>

<div style="page-break-before: always"></div>
<p id="GitBranchWorkflow">Git Workflow diagram:</p>
<div><img src="_img/Workflows.png" alt="Workflows" /></div>

<!-- @marker "Release Branches" -->
<h4 id='ReleaseBranches_'>Release Branches</h4>
<p><strong>Naming Convention</strong>: v&lt;versionNum&gt;, using semantic versioning</p>
	<div class="paragraphs">
		<p>When master is ready for a release, we assign a version number and create a release branch with name 'release-&lt;versionNum&gt;'.
			The separate release branch supports version updating and minor bug fixes on the release branch,
			while allowing work to proceed on master and feature branches.</p>
		<p>As soon as the branch has been created, we update ("bump") the version number. Bug-fix commits may also be added.</p>
		<p>Work from the release branch is merged into master when the release branch is tagged and closed.
			Bug fixes may be incorporated sooner as indicated.</p>
	</div>

	<div class="paragraphs">
		<p>Release branches are intended to isolate their work from the rest of the project workflow.
		There are no updates or merges with other repository branches.</p>
	</div>

<h5>Implementation</h5><ul>
	<li>When master is ready for a release,
		we assign a version number and create a release branch with name 'release-&lt;versionNum&gt;'.<ul>
		<li>The separate release branch supports version updating and minor bug fixes on the release branch,<br />
				while allowing work to proceed on master and feature branches.</li></ul></li>
	<li>As soon as the branch has been created, we update ("bump") the version number. Bug-fix commits may also be added.</li>
	<li>Work from the release branch is merged into master when the release branch is tagged and closed.
		Bug fixes may be incorporated sooner as indicated.</li>
	<li>Release branches are intended to isolate their work from the rest of the project workflow.
		There are no updates or merges with other repository branches.</li>
</ul>

	<div class="paragraphs">
		<p class="blurb">Historical Note: Until 6/16/16, we did not have a procedure for handling versioned releases,
			although both Accessor and Support were assigned version 0.1 in a previous attempt.
			We will rename the previous versions, and restart with v0.0 now.</p>
	</div>

<h5>Thoughts on Continuous Integration</h5><ul>
	<li>The current (2018.08.06) prevailing wisdom in devOps appears to be to release continuously.</li>
	<li>We had been concerned about the policy of closing a high-level task without looking back to see
		if we had accomplished what we intended,</li>
	<li>As a user of some products using Continuous Integration, including JetBrains, we have now seen:<ul>
		<li>changes that turned out to be related to upcoming features,
			but that did not make sense when we first saw them</li>
		<li>more bugs in those areas than we expect from their developers</li>
	</ul></li>
</ul>

<h5>Historical Note</h5><ul>
	<li class="blurb">Until 6/16/16, we did not have a procedure for handling versioned releases,
		although both Accessor and Support were assigned version 0.1 in a previous attempt.<br />
		We will rename the previous versions, and restart with v0.0 now.</li>
</ul>

<!-- @marker "Hotfix Branches" -->
<h4 id='Hotfix_Branches_'>Hotfix Branches</h4>
<p><strong>Naming Convention</strong>: hotfix-v&lt;versionNum&gt;</p>
	<div class="paragraphs">
		<p>Hotfix Branches are a special case of Release branches, and are handled in much the same way.</p>
		<p>Hotfix branches are created to fix bugs in released software that must be fixed before the next Release branch.
			They are checked out from the tip of the latest release tag
			(<span class="mono">git checkout tags/&lt;latestVersionTag&gt; -b hotfix-&lt;versionNum&gt;)</span></p>
		<p>The three parts of the semantic version number are major release; minor release; bug fix. Hotfix branches correspond to bug fixes.</p>
	</div>
<h2 id="WorkflowAppCode">Workflow: AppCode with Waffle</h2>
<div style="page-break-before: always">
 	<!-- @marker "Feature Branch Workflow" -->
	<h3 id='Feature_Branch_Workflow_' class="wf-feature">Feature Branch Workflow</h3><div class="wf-feature"><ul>
			<li id="ws_push"><span class="step">Push:</span> push current local branch to its remote<ul>
				<li>push; if rejected(?), synchronize again and retry</li>
			</ul></li>
			<li id="ws_SyncMaster"><span class="step">Sync Master:</span> synchronize local and remote master branches<ul>
				<li>checkout master; test; fetch origin/master; test; merge; test; commit; <span class="step"><a href="#ws_push">push</a></span></li>
			</ul></li>
			<li id="ws_UpdateBranch"><span class="step">Update Branch:</span> Merge Master into Branch<ul>
				<li><span class="step"><a href="#ws_SyncMaster">Sync Master</a></span>;
					checkout branch; merge in master; test; <span class="step"><a href="#ws_push">push</a></span></li>
			</ul></li>
			<li id="ws_MergeBranch"><span class="step">Merge Branch:</span> merge branch into main line of development<ul>
				<li><span class="step"><a href="#ws_SyncMaster">Sync Master</a></span>; checkout master; test;
					merge in branch; test; <span class="step"><a href="#ws_push">push</a></span></li>
			</ul></li>
			<li>for merge issues:&nbsp;&nbsp;<span class='mono'><span class="prompt">$</span> git revert --no-commit</span></li>
		</ul>
		<h4>While Issue Not Complete</h4>
			<h5>While Task(s) Not Complete</h5><div class="indent">
				<div class="wf-openTask">
				<h6>OpenTask</h6><ul>
					<li>clean up stashes</li>
					<li><strong>New Task</strong>: <span class="step"><a href="#ws_SyncMaster">Sync Master</a></span>; create new task with branch name
						&lt;productID&gt;-&lt;issueID&gt;-short-desc; test; <span class="step"><a href="#ws_push">push</a></span></li>
					<li>or <strong>Existing Task</strong>: switch to task; <span class="step"><a href="#ws_UpdateBranch">Update Branch</a>;
						</span>commit; test; <span class="step"><a href="#ws_push">push</a></span></li>
				</ul></div>
				<div class="indent2"><div class="wf-developCommit">
				<h6><a name="wf_Develop">Develop</a></h6><ul>
					<li>UI: verify Task and Branch</li>
					<li>repeat to commit:<ul>
						<li>develop; inspect; test; [ diff modifications; add/stage ]</li>
					</ul></li>
				</ul>
				<h6 id='wf_Commit'>Commit</h6><ul>
					<li>test; inspect; check for stashes, todo's</li>
					<li>if [ inspection issues | stashes | todo's | settings to export ]: address as indicated</li>
					<li>check for complete commit:&nbsp;&nbsp;<span class='mono'><span class="prompt">$ </span>git cherry -v master</span></li>
					<li>test; commit; <span class="step"><a href="#ws_push">push</a></span></li>
					<li><span class="step"><a href="#ws_UpdateBranch">Update Branch</a></span></li>
				</ul>
			</div></div>
			<div class='indent'><div class="wf-publish">
			<h6>Publish</h6><ul>
				<li>check for complete commit:&nbsp;&nbsp;<span class='mono'><span class="prompt">$ </span>git cherry -v master</span></li>
				<li><span class="step"><a href="#ws_MergeBranch">Merge Branch</a></span></li>
				<li>UI: synchronize Task and Branch</li>
				<li>if task complete, delete task and local branch</li>
			</ul></div></div></div></div></div>
			<div class='indent'><div class="wf-feature">
			<h6>Trigger Review</h6><ul>
				<li>set issue state to Review</li>
			</ul>
		</div></div>

	<div style="page-break-before: always">
		<h5>Issue Tasks Complete</h5><div class='indent'><div class="dq">
			<div class="wf-mergeReview">
			<h6>Initiate Review</h6><ul>
				<li>master branch; check VCS log</li>
				<li>change issue's status from 'SwimIssue' to 'needs review'</li>
			</ul>
			<h6>Review</h6><ul>
				<li>review code; add issues as indicated</li>
			</ul></div>
			<div class="wf-close">
			<h6>Code Review Complete: Close Issue</h6><ul>
				<li>test; check for unmerged  branches, pending stashes</li>
				<li>close issue</li>
				<li>address any unmerged branches and/or pending stashes</li>
			</ul>
		</div></div></div>
		<h5>[Archive Repository]</h5>
		<h5>Review</h5><ul>	<!-- git \todo: incorporate -->
			<li>Evaluate completeness of solution as specified.</li>
			<li>Evaluate completeness of automated and, if required, manual testing.</li>
			<li>Verify test completeness and results.</li>
			<li>Review code for cleanness, refactoring opportunities, ...</li>
		</ul>
	</div>

<div style="page-break-before: always">
	<!-- @marker "Release and Hotfix Branches" -->
	<div style="background-color: #e2faff">
	<h3 id='Release_Hotfix_Workflow_' class="wf-hotfix">Release and Hotfix Workflow</h3>
	<div class="wf-hotfix">
		<p><strong>WARNING:</strong> Feature branches are updated frequently to and from master.
			Updating to and from master is avoided in this workflow to prevent pollution of the release branch.</p>
	<h5>Create Release or Hotfix Branch</h5><div class="wf-createRelease"><ul>
		<li>Hotfix:<ul>
			<li>stash any active branches</li>
		</ul></li>
		<li>Release:<ul>
			<li>make sure all intended branches and stashes for this release are successfully merged<ul>
				<li>cleanup old branches and stashes; <a href="#wf_Develop">develop</a> / commit / publish if indicated</li>
			</ul></li>
		</ul></li>
		<li>select semantic version number/name, eg. v1.0.1</li>
		<li>establish milestone and parent version<ul>
			<li>Hotfix branch:<ul>
				<li>add milestone 'v&lt;versionNum&gt;'; describe hotfix in milestone text</li>
				<li>parent is the tagged release from which the hotfix will branch</li>
			</ul></li>
			<li>other Release branches<ul>
				<li>rename milestone nextVersion to 'v&lt;versionNum&gt;'; edit existing content to release description</li>
				<li>add new milestone nextVersion; transfer any open tasks there</li>
				<li>parent is master branch</li>
			</ul></li>
			<li>versionName is now 'v&lt;versionNum&gt;'</li>
		</ul></li>
	</ul></div>
	<div class="wf-openTask"><ul>
		<li>GitHub: from repository's Code tab, select "&lt;n&gt; releases"; create and save draft of revision &lt;versionName&gt;</li>
		<li>TCP (test; [commit, push])</li>
		<li>ensure parent branch is checked out<ul>
			<li>when parent is not master, use <span class="mono">git checkout -b release-&lt;versionName&gt; &lt;parentTag&gt;</span></li>
		</ul></li>
		<li>create task 'release-&lt;versionName&gt;' based on parent branch</li>
	</ul></div>
	<div class="wf-developCommit"><ul>
		<li>Hotfix: cycles <a href="#wf_Develop">develop/TCP</a> as indicated</li>
	</ul></div>
	<div class="wf-publish"><ul>
		<li>TCP</li>
		<li>add result of <span class="mono">git cherry -v &lt;mostRecentTag&gt; to release milestone</span></li>
		<li>bump version: change all version numbers that appear in product<ul>
			<li>change version numbers in most project files</li>
			<li>...</li>
		</ul></li>
		<li>commit ("bump version to &lt;versionName&gt;"); push</li>
		<li>Git &gt; tag &lt;versionName&gt;"; push branch and tags</li>
	</ul></div>
	<h5>Code Review</h5><div class="wf-triggerReview"><ul>
		<li>change Waffle label from Waffle:in progress to Waffle:needs review</li>
		<li>NO MORE UPDATES from master</li>
		<li>for identified changes needed:<ul>
			<li>create task/branch based on tagged branch</li>
			<li>ginfo.sh; TCP; edit; test; add/stage; TCP</li>
		</ul></li>
	</ul></div>
	<h5>Finish</h5><div class="wf-close"><ul>
		<li>if indicated, update master from release</li>
		<li>master branch; merge in tagged release branch; test; [commit]; PUSH</li>
		<li>GitHub: from draft of Release: add product if indicated; publish</li>
		<li>delete release task and local branch</li>
	</ul></div>
	<h5>Archive Repository</h5>
	</div></div></div>

<div style="page-break-before: always">
	<!-- @marker "Workflow Subtasks" -->
	<h3>Workflow Subtasks</h3>
	<!-- @topicList "Workflow Subtasks" "workflowSubtasks" -->
		<!-- @topicItem "Naming Conventions" "#namingConventions" "0" "" -->
		<!-- @topicItem "Commit Message Conventions" "#commitMessageConventions" "0" "" -->
		<!-- @topicItem "Compare Revisions" "#adminCompareRevisions" "0" "" -->
		<!-- @topicItem "Compare Ancestry" "#adminCompareAncestry" "0" "" -->
		<!-- @topicItem "Bash Debug Logging" "#adminDebugLogging" "0" "" -->
		<!-- @topicItem "Resolve Conflicts" "#adminResolveConflicts" "0" "" -->
		<!-- @topicItem "Fix Divergent Branches" "#adminFixDivergentBranches" "0" "" -->
		<!-- @topicItem "Checkout Remote Branch" "#CheckoutRemoteBranch_" "0" "" -->
		<!-- @topicItem "Checkout from Stash" "#CheckoutFromStash" "0" "" -->
		<!-- @topicItem "Rebase Commits" "#RebaseCommits" "0" "" -->
		<!-- @topicItem "emacs Commands" "#emacsCommands" "0" "" -->
	<!-- @/topicList -->

	<div style="background-color: #deedf8">
		<!-- @marker "Naming Conventions" -->
		<h6 id='namingConventions'>Naming Conventions</h6><ul>
			<li>feature branches and associated tasks: &lt;task-desc&gt;-#&lt;issueNum&gt;</li>
			<li>release branches and associated tasks: <span class="mono">release-v&lt;versionNum&gt;</span></li>
			<li>hotfix branches and associated tasks: <span class="mono">hotfix-v&lt;versionNum&gt;</span></li>
		</ul>

		<!-- @marker "Commit Message Conventions" -->
		<h6 id='commitMessageConventions'>Commit Message Conventions</h6><ul>
			<li><em>GitHub and Waffle take actions based on some appearances of issueIDs in commit messages</em></li>
			<li>to close associated issue: add (close | fix | resolve)#&lt;issueID&gt; to commit message</li>
			<li>to connect to another issue: connect#&lt;ID&gt;</li>
		</ul>


		<h6 id='adminCompareRevisions'>Compare Revisions</h6><ul>
			<li><span class='em'>Compare</span>: (<span class='mono'>difftool --name-status first..second; lg first..second</span>)</li>
		</ul>

		<h6 id='adminCompareAncestry'>Compare Ancestry</h6><ul>
			<li><span class='em'>Ancestry</span>: (<span class='mono'>difftool --name-status first...second; lg first..second</span>)</li>
			<li class='ital'>difference between Compare Revisions and Compare Ancestry is the extra dot in difftool for Ancestry</li>
		</ul>

		<h6 id="adminDebugLogging">Bash Debug Logging</h6><ul>
			<li>add logger Live Template to code: `logger "$0#$LINENO: | #"`</li>
			<li>enter information to be logged at cursor, &lt;logtag&gt; content after '#'</li>
			<li>run code to make entries in syslog</li>
			<li>Terminal: <span class="mono">syslog | grep "#&lt;logtag&gt;"</span> to display tagged information</li>
		</ul>

		<h6 id='adminResolveConflicts'>Resolve Conflicts</h6><ul>
			<li>status</li>
			<li>if conflicts: <span class='mono'>merge resolve</span> (mergetool), saving successfully merged files<ul>
				<li>to choose one file, use <span class='mono'>checkout --[ours | theirs]</span> for local or merge target, respectively</li>
			</ul></li>
			<li class='ital'>if fetchup merge fails, could try: <span class='mono'>git rebase --preserve-merges @{u}</span></li>
			<li><span class='mono'>commit / resolve merge</span></li>
			<li>OR to undo merge: <span class='mono'>git merge --abort</span></li>
			<li>to recover corrupted project file: close in Xcode; diff fileMerge with previous good copy; edit manually</li>
		</ul>

		<!-- @marker "adminFixDivergentBranches" -->
		<h6 id='adminFixDivergentBranches'>Fix Divergent Branches</h6><ul>
			<li>use 'git rebase'</li>
		</ul>

		<!-- @marker "Checkout Remote Branch" -->
		<h6 id='CheckoutRemoteBranch_'>Checkout Remote Branch</h6><ul>
			<li>git checkout -b &lt;branchName&gt; origin/&lt;branchName&gt;</li>
		</ul>

		<!-- @marker "Checkout Stash as Branch" -->
		<h6 id='CheckoutFromStash'>Checkout from Stash</h6><ul>
			<li><span class="mono">git stash branch &lt;branchname&gt; [@stash{n}]</span>&nbsp;&nbsp;# checkout stash to branch</li>
			<li><span class="mono">git checkout stash@{0} -- &lt;filename&gt;</span>&nbsp;&nbsp;# checkout single file</li>
		</ul>

		<!-- @marker "Rebase Commits" -->
		<h6 id='RebaseCommits'>Rebase Commits</h6><ul>
			<li><strong>-- ONLY for commits that have not been pushed</strong></li>
			<li class="mono">git rebase -i HEAD~&lt;#commits&gt;</li>
			<li>edit commands (pick, squash, reword, ...); save<ul>
				<li>for reword: edit messages as they are shown</li>
				<li>for rebase: <ul>
					<li>git rebase --continue</li>
					<li>edit comment; save</li>
				</ul></li>
			</ul></li>
		</ul>

		<!-- @marker "emacs Commands" -->
		<h6 id='emacsCommands'>emacs Commands</h6><ul>
			<li>save: rX-S; exit: rX-rC; kill: rK</li>
			<li>cut: rW; copy: oW; paste: rY</li>
		</ul>

	</div></div>

<!-- @marker "Git Tasks" -->
<div style="page-break-before: always">
<h2>Git Tasks</h2>
</div>
<!-- @topicList "Git Tasks" "GitTasks_" -->
	<!-- @topicItem "NewRepo" "#tsk_NewRepo" "0" "" -->
	<!-- @topicItem "Branch" "#tsk_Branch" "1" "" -->
	<!-- @topicItem "Master Branch" "#tsk_MasterBranch" "1" "" -->
	<!-- @topicItem "Stash" "#tsk_Stash" "1" "" -->
	<!-- @topicItem "Cherry" "#tsk_Cherry" "1" "find commits not in branch" -->
	<!-- @topicItem "Diff" "#tsk_Diff" "1" "" -->
	<!-- @topicItem "Commit" "#tsk_Commit_" "1" "" -->
	<!-- @topicItem "Tag" "#tsk_Tag" "1" "" -->
	<!-- @topicItem "Remove Repository File(s)" "#Remove_Repository_File_" "1" "" -->
	<!-- @topicItem "Bisect" "#tsk_Bisect" "1" "" -->
	<!-- @topicItem "Information" "#tsk_Information" "1" "" -->
	<!-- @topicItem "Undo" "#tsk_Undo" "1" "" -->
	<!-- @topicItem "Fix Line Endings" "#tsk_FixLineEndings" "1" "" -->
<!-- @/topicList -->

<!-- @marker "NewRepo" -->
<h4 id="tsk_NewRepo">NewRepo</h4><div class="indent">
	<h5>create and clone initial repo</h5><ul>
		<li class="mono">git remote add origin https://github.com/&lt;userName&gt;/&lt;projectName&gt;.git</li>
		<li class="mono">cd &lt;parentFolderForNewRepo&gt;</li>
		<li class="mono">git clone https://github.com/&lt;userName&gt;/&lt;projectName&gt;.git</li>
	</ul>
	<h5>add readme file</h5><ul>
		<li class="mono">echo "# &lt;repoName&gt;" &gt; README.md</li>
		<li class="mono">git add --all</li>
		<li class="mono">git commit -m "initial commit"</li>
	</ul>
	<h5>add license, normally MIT</h5><ul>
		<li>GitHub, from main page of new repository: Create new file named LICENSE or LICENSE.md</li>
		<li>select 'Choose a license template'; select license; 'Review and submit'</li>
		<li class="mono">git commit -m "add &lt;licenseType&gt; license"</li>
	</ul>
	<h5>push</h5><ul>
		<li class="mono">git push -u origin master</li>
	</ul>
</div>

<!-- @marker "Branch" -->
<h4 id="tsk_Branch">Branch</h4><ul>
	<li><span class='mono'>git branch</span>&nbsp;&nbsp;# to list current branches<ul>
		<li><span class='mono'>--remotes</span>&nbsp;&nbsp;# to list remote branches</li>
		<li><span class='mono'>--all</span>&nbsp;&nbsp;# to list both local and remote branches</li>
		<li><span class='mono'>--no-merged</span>&nbsp;&nbsp;# check for unmerged branches</li>
		<li><span class='mono'>--move [&lt;oldbranch&gt;] &lt;newbranch&gt;</span>&nbsp;&nbsp;# to rename a branch<ul>
			<li>then, to rename remote branch to match:<ul>
				<li class='blurb'>this assumes remote branch is named 'origin'; can use <span class='mono'>git remote -v</span> to verify</li>
				<li><span class='mono'>git push origin :&lt;oldBranch&gt;&nbsp;&nbsp;# delete old remote branch</span></li>
				<li><span class='mono'>git push --set-upstream origin &lt;newBranch&gt;&nbsp;&nbsp;# recreate remote branch with new name</span></li>
			</ul>
		</li>
		</ul></li>
		<li><span class='mono'>--delete &lt;branchname&gt;</span>&nbsp;&nbsp;# delete a branch<ul>
			<li class='blurb'>also see git docs for information about deleting and cleaning up remote branches</li>
		</ul></li>
	</ul></li>
	<li><span class='mono'>git checkout -b &lt;new-branch&gt; [&lt;start_point&gt;]</span>&nbsp;&nbsp;# move existing work to a new branch, rooted at commit &lt;start_point&gt; if specified</li>
	<li>list branches by date:&nbsp;&nbsp;<span class='mono'>
			<span class="prompt">$ </span>for k in `git branch | sed s/^..//`; do echo -e `git log -1 --pretty=format:"%Cgreen%ci %Cblue%cr%Creset" $k --`\\t"$k";done | sort</span></li>
</ul>

<!-- @marker "Master Branch" -->
<h4 id="tsk_MasterBranch">Master Branch</h4>
	<h5><a id="tsk_MergeMaster">Merge Master</a></h5><ul>
		<li class="blurb">used with Xcode; otherwise, AppCode's own merge is used</li>
		<li>checkout branch; set $cb; show --name-status; <a href="#adminCompareAncestry"><span class='em'>Ancestry</span></a> $cb.master</li>
		<li>if changed:<ul>
			<li>merge mergeMaster <span class='mono'>(--no-ff -m "merge master")</span>; status; <a href="#adminResolveConflicts"><span class='em'>Resolve Conflicts</span></a></li>
			<li>test; show; <a href="#adminCompareRevisions"><span class='em'>Compare</span></a> origin/$cb.$cb; push</li>
		</ul></li>
	</ul>

	<h5><a id="tsk_UpdateMaster">Update Master</a></h5><ul>
		<li class="blurb">not needed for now; purpose is to update our code with work from others</li>
		<li>checkout master; verify status clean</li>
		<li>fetch updates (<span class='mono'>git remote update --prune</span>); status</li>
		<li>if changed: merge updateMaster (<span class='mono'>git merge --ff-only @{u}</span>)</li>
		<li><a href="#adminResolveConflicts"><span class='em'>Resolve Conflicts</span></a>; test; push</li>
	</ul>

<!-- @marker "Stash" -->
<h4 id="tsk_Stash">Stash</h4><ul>
	<li><span class='mono'>git stash save &lt;name&gt;</span>&nbsp;&nbsp;# save stash named &lt;name&gt;; leave working directory clean<ul>
		<li><span class='mono'>add --keep-index</span>&nbsp;&nbsp;# to leave all changes already added to the index intact</li>
	</ul></li>
	<li>apply:<ul>
		<li><span class='mono'>git stash apply</span>&nbsp;&nbsp;# to apply the top stash to the current working copy</li>
		<li><span class='mono'>git stash branch</span>&nbsp;&nbsp;# to apply the top stash to a new branch based in the stash's base revision</li>
		<li><span class='mono'>git checkout stash@{n} -- &lt;filename&gt;</span>&nbsp;&nbsp;# to checkout a single file from a stash</li>
		<li>add <span class='mono'>stash@{&lt;index&gt;}</span>&nbsp;&nbsp;#  to specify a different stash</li>
	</ul></li>
	<li><span class='mono'>git stash list</span>&nbsp;&nbsp;# list all stashes in repository</li>
	<li><span class='mono'>git stash drop</span>&nbsp;&nbsp;# remove the specified stash</li>
	<li><span class='mono'>git stash show [stash@{n}]</span>&nbsp;&nbsp;# show details for the top or a specified stash</li>
</ul>

<!-- @marker "Cherry" -->
<h4 id="tsk_Cherry">Cherry</h4><ul>
	<li><span class="mono">git cherry</span>&nbsp;&nbsp;# list commits not included in current branch<ul>
		<li><span class="mono">-v </span>&nbsp;&nbsp;# include commit message in output</li>
		<li><span class="mono">&lt;branchName&gt;</span>&nbsp;&nbsp;# commits not included in specified branch</li>
	</ul></li>
</ul>

<!-- @marker "Diff" -->
<h4 id="tsk_Diff">Diff</h4>
	<h5>Diff Commands</h5><ul>
		<li><span class='mono'>git diff</span>&nbsp;&nbsp;# working copy and index (unstaged)</li>
		<li><span class='mono'>git diff --cached</span>&nbsp;&nbsp;# index and last commit (staged)</li>
		<li><span class='mono'>git diff HEAD</span>&nbsp;&nbsp;# working directory since your last commit (unstaged and staged)</li>
		<li><span class='mono'>git diff &lt;branch&gt;</span>&nbsp;&nbsp;# working copy and another branch</li>
		<li><span class='mono'>git diff &lt;branch1&gt;..&lt;branch2&gt;</span>&nbsp;&nbsp;# tips of the two branches</li>
		<li><span class='mono'>git diff &lt;branch1&gt;...&lt;branch2&gt;</span>&nbsp;&nbsp;# from their common ancestor to branch</li>
		<li><span class='mono'>git difftool &lt;arguments as above&gt;</span>&nbsp;&nbsp;# display results using FileMerge</li>
	</ul>
	<h5>Diff Options</h5><ul>
		<li><span class='mono'>-- ./path</span>&nbsp;&nbsp;# restrict to a path</li>
		<li><span class='mono'>--name-status</span>&nbsp;&nbsp;# one line per file (like svn status)</li>
		<li><span class='mono'>--pretty=oneline</span>&nbsp;&nbsp;# to show just sha and one-line comment</li>
		<li><span class='mono'>--graph</span>&nbsp;&nbsp;#  to show branch relationships<ul>
			<li>with <span class='mono'>--topo-order</span>&nbsp;&nbsp;# shows top-down so tree is clearer</li>
		</ul></li>
		<li><span class='mono'>--date-order</span>&nbsp;&nbsp;# to show chronologically</li>
	</ul>
	<h5>diff a previous version of a file</h5><ul>
		<li><span class='mono'>git lg --follow &lt;filename&gt;</span>&nbsp;&nbsp;# show changes to this file</li>
		<li><span class='mono'>st=&lt;shaTag&gt;</span>&nbsp;&nbsp;# set tag to target sha</li>
		<li><span class='mono'>git show --name-only &lt;shaTag&gt; </span>&nbsp;&nbsp;# see commit message; get file path<ul>
			<li>if file path is the same as current path:<ul>
				<li><span class='mono'>git difftool &lt;shaTag&gt; &lt;filename&gt;</span>&nbsp;&nbsp;# diff revisions</li>
			</ul></li>
			<li>else<ul>
				<li><span class='mono'>git checkout &lt;shaTag&gt; &lt;filename&gt;</span>&nbsp;&nbsp;# checkout file to compare</li>
				<li>use BBEdit to compare files</li>
			</ul></li>
		</ul></li>
	</ul>

<!-- @marker "Commit" -->
<h4 id="tsk_Commit_">Commit</h4><ul>
	<li class="blurb">Commit from Terminal when committing cached items only, which IntelliJ platform does not support.</li>
	<li>diff between branch and cached files:&nbsp;&nbsp;<span class='mono'><span class="prompt">$ </span>git difftool --cached (gdc)</span></li>
	<li>edit TextEdit file "${CCDev}/tmp/msg.txt" to contain git message</li>
	<li>dry-run commit:&nbsp;&nbsp;<span class='mono'><span class="prompt">$ </span>git commit --dry-run [--amend] -F ${CCDev}/tmp/msg.txt</span></li>
	<li>commit:&nbsp;&nbsp;<span class='mono'><span class="prompt">$ </span>git commit [--amend] -F ${CCDev}/tmp/msg.txt</span></li>
	<li>before pushing, diff log of this commit from IDE</li>
</ul>

<!-- @marker "Tag" -->
<h4 id="tsk_Tag">Tag</h4><ul>
	<li><span class='mono'>git tag</span>&nbsp;&nbsp;# list<ul>
		<li><span class='mono'>-l</span>&nbsp;&nbsp;# to match a pattern</li>
	</ul></li>
	<li><span class='mono'>git tag -a &lt;tag&gt; -m '&lt;msg&gt;'</span>&nbsp;&nbsp;# create</li>
	<li><span class='mono'>git tag -d &lt;tag&gt;</span>&nbsp;&nbsp;# delete</li>
	<li><span class='mono'>git tag &lt;new&gt; &lt;new&gt;;git tag -d &lt;old&gt;; git push origin :&lt;old&gt;; git push --tags</span>&nbsp;&nbsp;# rename</li>
	<li><span class='mono'>git ls-remote --tags origin</span>&nbsp;&nbsp;# list remote tags</li>
	<li><span class='mono'>git show &lt;tag&gt;</span>&nbsp;&nbsp;# show information about &lt;tag&gt;</li>
	<li><span class='mono'>git push --tags</span>&nbsp;&nbsp;# push tags</li>
	<li><span class="mono">&lt;sha&gt;</span>&nbsp;&nbsp;# add to select another commit</li>
</ul>

<!-- @marker "Remove Repository File(s)" -->
<h4 id='Remove_Repository_File_'>Remove Repository File(s)</h4><ul>
	<li><span class='mono'>git rm --cached &lt;filename&gt;</span>&nbsp;&nbsp;# remove file</li>
	<li><span class='mono'>git rm --cached -r &lt;directory&gt;</span>&nbsp;&nbsp;# remove directory</li>
</ul>

<!-- @marker "Bisect" -->
<h4 id='tsk_Bisect'>Bisect</h4><ul>
	<li><span class='mono'>git checkout -b &lt;newbranch&gt;</span>&nbsp;&nbsp;# checkout a new branch<ul>
		<li><strong>Detached Head</strong><ul>
			<li>If accidentally done from the master branch, a detached head is possible. Correct by checking the work out into  new branch, which restores master to its previous state.</li>
		</ul></li>
	</ul></li>
	<li><span class='mono'>git bisect start</span>&nbsp;&nbsp;# start a bisect operation<ul>
		<li class='blurb'>then execute <span class='mono'>good</span> and <span class='mono'>bad</span> to establish range</li>
	</ul></li>
	<li><span class='mono'>git bisect bad</span>&nbsp;&nbsp;# mark current bisect commit as bad</li>
	<li><span class='mono'>git bisect good</span>&nbsp;&nbsp;# mark current bisect commit as good</li>
	<li><span class='mono'>git bisect skip</span>&nbsp;&nbsp;# skip current bisect commit</li>
	<li><span class='mono'>git bisect reset</span>&nbsp;&nbsp;# clean up from a bisection</li>
	<li><span class='mono'>git bisect log</span>&nbsp;&nbsp;# show log of current bisection</li>
	<li><span class='mono'>git bisect replay</span>&nbsp;&nbsp; &lt;logfile&gt; # replay bisection from edited log output &lt;logfile&gt;</li>
</ul>

<!-- @marker "Information" -->
<h4 id="tsk_Information">Information</h4>
	<h5>Log Commands</h5><ul>
		<li><span class='mono'>git log &lt;tag&gt;..</span>&nbsp;&nbsp;# commits since (not reachable from) &lt;tag&gt;</li>
		<li><span class='mono'>git log &lt;branch&gt;..master</span>&nbsp;&nbsp;# commits reachable from master but not &lt;branch&gt;</li>
		<li><span class='mono'>git log master..&lt;branch&gt;</span>&nbsp;&nbsp;# commits reachable from &lt;branch&gt; but not master</li>
		<li><span class='mono'>git log master...&lt;branch&gt;</span>&nbsp;&nbsp;# commits reachable from either &lt;branch&gt; or master, but not both</li>
		<li><span class='mono'>git log &lt;folder&gt;/</span>&nbsp;&nbsp;# commits that modify any file under &lt;folder&gt;/</li>
		<li><span class='mono'>git lg</span>&nbsp;&nbsp;# in-house alias to display single-line log output</li>
	</ul>
	<h5>Log Options</h5><ul>
		<li><span class='mono'>git log --since="2 weeks ago"</span>&nbsp;&nbsp;# commits from the last 2 weeks</li>
		<li><span class='mono'>git log &lt;filename&gt;</span>&nbsp;&nbsp;# commits that modify &lt;filename&gt;</li>
		<li><span class='mono'>git log -S'&lt;pattern&gt;'</span>&nbsp;&nbsp;# commits that add or remove any file data matching the string '&lt;pattern&gt;'</li>
		<li><span class='mono'>git log --no-merges</span>&nbsp;&nbsp;# skip merge commits</li>
		<li><span class='mono'>git log --follow</span>&nbsp;&nbsp;# follow file through renames if any</li>
	</ul>
	<h5>Other Information Commands</h5><ul>
		<li><span class='mono'>git ls-files --other --exclude-standard</span>&nbsp;&nbsp;# untracked files</li>
		<li><span class='mono'>git branch --no-merged</span>&nbsp;&nbsp;# check for unmerged branches</li>
		<li><span class='mono'>git reflog [log options | with dates(custom)]</span>&nbsp;&nbsp;# show reflog</li>
	</ul>

<!-- @marker "Fix Line Endings" -->
<h4 id='tsk_FixLineEndings'>Fix Line Endings</h4><ul>
	<li class='blurb'>for fixing line endings when adding files from an external source<ul>
		<li>see <a href="http://help.github.com/articles/dealing-with-line-endings/">GitHub: Dealing With Line Endings</a></li>
		<li>We used a slightly modified version of this technique when importing the pyparser script and its support. It seems to have worked fine, although after the reset step there were no files to add, and we were done.</li>
		<li>These steps show what we actually planned/did.</li>
	</ul></li>
	<li>checkin the files</li>
	<li>remove files from working tree and index: <span class='mono'>git rm --cached -r &lt;pathnames, eg. fldr/*&gt;</span></li>
	<li>rewrite the files back, with corrected line endings: <span class='mono'>git reset --hard</span></li>
	<li>if necessary:<ul>
		<li>add the files back into the index: <span class='mono'>git add --all</span><ul>
			<li class='blurb'>messages "warning: CRLF will be replaced by LF in file." are ok</li>
		</ul></li>
		<li><span class='mono'>git commit -m "normalize line endings"</span></li>
	</ul></li>
</ul>

<!-- @marker "Undo" -->
<h4 id="tsk_Undo">Undo</h4><ul>
	<li><span class='mono'>git checkout -- &lt;file&gt;</span>&nbsp;&nbsp;# restore one file to version in index</li>
	<li><span class='mono'>git checkout HEAD &lt;file&gt;</span>&nbsp;&nbsp;# restore one file to version in HEAD revision</li>
	<li><span class='mono'>git reset --soft HEAD@{1}</span>&nbsp;&nbsp;# undo last commit (set HEAD to point to parent of HEAD)</li>
	<li><span class='mono'>git reset --mixed HEAD@{1} (default)</span>&nbsp;&nbsp;# also update index to match new HEAD; same as unstaging everything</li>
	<li><span class='mono'>git revert [HEAD|&lt;commit&gt;]</span>&nbsp;&nbsp;# creates a new commit that undoes the most recent or a previous commit</li>
	<li><span class='mono'>git reflog; git checkout &lt;sha&gt;; git checkout -b &lt;branch&gt;</span> find and restore recently deleted branch</li>
	<li><a href="https://github.com/git/git/blob/master/Documentation/howto/revert-a-faulty-merge.txt">revert a faulty merge</a></li>
	<li><a href="https://github.com/blog/2019-how-to-undo-almost-anything-with-git">How to undo (almost) anything with Git</a></li>
	<li><span class='mono'>git reset --hard HEAD</span>&nbsp;&nbsp;# discard all changes since last commit; restores index and files; then:<ul>
		<li>master branch; make small change somewhere (ReadMe?); commit master branch; push master (requires -f?)</li>
		<li>rename branches between old and new heads to avoid accidental use<ul>
			<li>to determine which branches were affected by the reset (have commits between old and new heads): list branches by date of last commit:<ul>
				<li class="mono">for k in `git branch -r | perl -pe 's/^..(.*?)( ->.*)?$/\1/'`; do echo -e<br />
					`git show --pretty=format:"%Cgreen%ci %Cblue%cr%Creset" $k -- | head -n 1`\\t$k; done | sort -r</li>
			</ul></li>
			<li>for each branch to be renamed:<ul>
				<li>checkout branch; set $cb; checkout master</li>
				<li><span class="mono">git branch --move $cb inreset_$cb</span></li>
				<li>checkout $cb; <span class="mono">git push origin :$cb</span></li>
				<li><span class="mono">git push --set-upstream origin inreset_$cb</span></li>
			</ul></li>
		</ul></li>
	</ul></li>
	<li><strong>Recovering from Problem Branches</strong><ul>
		<li><em>Sometimes we must deal with branches that have content we want, but that also
			include bad changes, require a merge commit that is too complex to be safe...</em></li>
		<li><em>Our preferred strategy is to save both patches and a backup copies of the target files, and then
			try one strategy, with the other available if problems are encountered.</em></li>
		<li><strong>Recovery strategy</strong><ul>
			<li>for intended changes: leave the existing local branch in place, and probably push it<ul>
				<li><em>We consider all feature branches on the repo to be private,
					so there should be no work based on it. Also, for the foreseeable future,
					there are no other developers anyway.</em></li>
				<li>create new branch, and make the desired source code changes again</li>
			</ul></li>
		</ul></li>
		<li><strong>Procedure</strong><ul>
			<li>make backup copies of affected files</li>
			<li>determine revision &lt;sha&gt; to start with - a spot where master and branch match</li>
			<li>generate multiple patches for the problem branch<ul>
				<li>on problem branch: <span class="mono">git format-patch &lt;sha&gt;</span></li>
				<li>WARNING: If/when patches are applied, there must be NO CHANGES to any affected files
					from the time the patch files are generated and until the patches have all been applied.
					If changes are made, remaining patches will not apply cleanly, which will break the process.</li>
			</ul></li>
			<li>checkout master</li>
			<li>move HEAD to point to &lt;sha&gt;: <span class="mono">git reset --hard &lt;sha&gt;</span></li>
			<li>compare local master with origin/master to verify that local master is as expected</li>
			<li>commit and push master: <span class="mono">git push --force origin master</span></li>
			<li>IDEA: create new task based on *master* for the rebuilt branch</li>
			<li>on new branch, push: <span class="mono">git push --force origin &lt;branch&gt;</span></li>
			<li>choose: IDEA diff | git patch<ul>
				<li>IDEA diff<ul>
					<li>diff: target branch with tip of original branch<ul>
						<li>for each group of changes:<ul>
							<li>make changes by applying original branch changes to target branch</li>
							<li><a href='#wf_Commit'>commit</a></li>
						</ul></li>
					</ul></li>
				</ul></li>
				<li>git patch<ul>
					<li>for each patch, sequentially</li>
						<li>apply to new branch: <span class="mono">git apply &lt;patchNumber&gt;-*.patch</span><ul>
						<li>use diff from IDEA as indicated to examine and plan changes</li>
						<li>on receiving branch:<ul>
							<li>TextEdit: edit and save commit message in file <span class='mono'>${HOME}/Library/CCDev/tmp/msg.txt</span></li>
							<li>add selected hunks: <span class='mono'>git add [ -i | --interactive ]</span> (alias 'gai')<ul>
								<li>to undo: <span class='mono'>git reset &lt;filename&gt;</span></li>
							</ul></li>
							<li>view changes: <span class='mono'>git difftool --cached</span> (alias 'gdc')</li>
							<li><span class='mono'>cat ${HOME}/Library/CCDev/tmp/msg.txt</span> (alias gcsm)</li>
							<li><span class='mono'>git commit -F ~/Library/CCDev/tmp/msg</span>(alias gcmf)</li>
							<li>push</li>
						</ul></li>
						<li>repeat until all changes in this patch have been committed</li>
					<li>continue until all patches have been handled</li>
				</ul></li>
			</ul></li>
			<li><a href="http://candcsoft.com/TechnicalDocs/DevSupport/Git.html#merge_master_">merge master</a></li>
			<li><a href="http://candcsoft.com/TechnicalDocs/DevSupport/Git.html#publish_">publish</a> and continue</li>
		</ul></li>
	</ul></li>
</ul></li>
</ul>

<!-- @marker "References" -->
<h2 id='_References'>References</h2><ul>
	<li><a href="https://git-scm.com/docs/">Pro-Git</a></li>
	<li><a href="http://paul.stadig.name/2010/12/thou-shalt-not-lie-git-rebase-ammend.html">Paul Stadig: Thou Shalt Not Lie</a></li>
	<li><a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a> <span><em>gitflow</em></span></li>
	<li><a href="https://help.github.com/articles/creating-releases/">GitHub: Creating Release</a></li>
	<li><a href="https://help.github.com/articles/linking-to-releases/">GitHub: Linking to releases</a> </li>
	<li><a href="https://www.viget.com/articles/successful-release-management-and-how-to-communicate-about-it">Managing a Successful Release Process</a></li>
</ul>

<!-- @marker "Notes" -->
<h2>Notes</h2>
<!-- @topicList "Notes" "GitNotes_" -->
<!-- @/topicList -->

<ul>
	<li>rebase only to rebase an existing branch on more current code or clean up a current, unmerged branch; see <a href="http://paul.stadig.name/2010/12/thou-shalt-not-lie-git-rebase-ammend.html">Paul Stadig: Thou Shalt Not Lie</a></li>
	<li class='dq'>sha/date marker: used in history and thread files to support matching history with repository<ul>
		<li>Setting the sha/date marker replaces the clearly-visible (from source code) commit message and notes with the sha/date marker. A branch's sha/date is often updated from another branch.</li>
		<li><span class='mono'>print "[$(cd /Users/carolclark/Dev/${proj}; git log -1 --pretty=format:'%h') $(date +%m/%d/20%y) &lt;placeholder&gt;]"</span></li>
	</ul></li>
</ul>

<p>
config, admin only: git remote add remote /Volumes/carollclark/gitrep/PunkinRemote	# adds PunkinRemote as remote "remote"
to replace an existing working copy with a newly-cloned one, first remove the existing repository from Xcode's repository list, close the Xcode workspace, and quit Terminal (BBEdit project?)<br />
my working copy has a branch for Laura's stuff (she pushes to Remote; I integrate and push to Main)<br />
internal: threads; branches; compound (here or with source control?)<br />
git diff master origin/master (same as master..origin/master?)<br />
see git-rev-parse<br />
see <a href="http://grit.rubyforge.org/">grit</a> for ruby scripting<br />
</p>

<hr class='footer' />
<p class='footer'>Copyright 2011-16 by C &amp; C Software, Inc. All rights reserved.</p>
<p class='footer'>Confidential and Proprietary.</p>
</body>
</html>
