<!-- Git.html -->
<!-- Created by Carol Clark on 24 Aug 2011 for project Support. -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Git</title>
	<link rel="stylesheet" type="text/css" href="../css/technical.css" />
	<style type="text/css">
		li.like-h6 {
			margin-top: 5px;
			margin-bottom: .2em;
			padding: 0;
			font-size: 12px;
			color: #000;
		}

		span.wf-developStart {
			font-style: italic;
			font-size: 75%;
			font-weight: normal;
			color: forestgreen;
		}

		span.bold-italic {
			font-weight: bold;
			font-style: italic;
		}

		span.warning {
			color: red;
		}

		/* workflow borders; provide color to help developer keep place in workflow */
		h3.wf-feature {
			color: blue;
		}
		div.wf-feature {
			border: 12px none blue;border-right-style: solid;
		}
		h3.wf-release-hotfix {
			color: deeppink;
		}
		div.wf-release-hotfix {
			border: 12px none deeppink;border-right-style: solid;
		}
		h6.wf-bump-version {
			color: gold;
		}
		div.wf-bump-version {
			border: 8px none gold;border-left-style: solid;
		}
		div.wf-openTask {
			border: 8px none lightgreen;border-left-style: solid;
		}
		div.wf-createRelease {
			border: 8px none burlywood;border-left-style: solid;
		}
		div.wf-developCommit {
			border: 8px none green;border-left-style: solid;
		}
		div.wf-publish {
			border: 8px none orange;border-left-style: solid;
		}
		div.wf-Review {
			border: 8px none purple;border-left-style: solid;
		}
		div.wf-triggerReview {
			border: 8px none mediumpurple;border-left-style: solid;
		}
		div.wf-close {
			border: 8px none purple;border-left-style: solid;
		}

		/* links: highlight tagged steps (top of Branch Workflow) and their links */
		.step {
			color: saddlebrown;
			font-weight: bold;
		}
		.step a:link {
			color: sienna;
		}
		.step a:hover {
			color: maroon;
		}
		.step a:visited {
			color: darkgoldenrod;
		}
		.step a:active {
			color: gold;
		}
	</style>
</head>
<body>
<!-- @navhead "DevSupport.html" "DevSupport" "History_Support.html" -->
<h1>Git</h1>
<!-- @topicList "Git" "Contents" -->
	<!-- @topicItem "Branches and Releases" "#Branches_Releases_" "0" "" -->
 	<!-- @topicItem "Daily Workflows" "#WorkflowIntelliJ" "0" "current workflow" -->
		<!-- @topicItem "Feature Branches" "#Feature_Branch_Workflow_" "1" "" -->
		<!-- @topicItem "Code Review" "#CodeReview" "1" "" -->
		<!-- @topicItem "Release and Hotfix Branches" "#Release_Hotfix_Workflow_" "1" "" -->
		<!-- @topicItem "Workflow Subtasks" "#workflowSubtasks" "1" "" -->
	<!-- @topicGroup "" "6" -->
	<!-- @topicItem "Git Tasks" "#GitTasks_" "0" "" -->
	<!-- @topicItem "References" "#_References" "0" "" -->
	<!-- @topicItem "Notes" "#GitNotes_" "0" "" -->
<!-- @/topicList -->

<!-- @marker "Branches and Releases" -->
<h2>Branches and Releases</h2>
<!-- @topicList "Branches and Releases" "Branches_Releases_" -->
	<!-- @topicItem "Feature Branches" "#FeatureBranches_" "0" "" -->
	<!-- @topicItem "Release Branches" "#Releases_" "0" "" -->
	<!-- @topicItem "Hotfix Branches" "#wf_release-hotfix" "0" "" -->
<!-- @/topicList -->

<!-- overview\summary --><ul>
	<li>Repositories are hosted at GitHub.</li>
	<li>Work is organized around YouTrack issues.
	YouTrack Epic issues with swimlanes group other issues into larger goals.</li>
	<li>Tasks are a fundamental element in our workflow. IntelliJ, our primary collection of IDEs, supports Tasks, each normally associated with a YouTrack task.</li>
	<li>YouTrack Agile boards, one each for backlog refinement and for development, help us to organize our work on epics, stories, and features.</li>
</ul><!-- overview\summary -->

<!-- @marker "Branch Types" -->
<h4 id='BranchesTypes_'>Branch Types</h4><ul>
	<li><em>Feature</em> branches are used to develop features for a future release.
		A feature branch is created from master, and merged back, if successful, to master.</li>
	<li><em>Release</em> branches are used when a product is released. We manage releases with GitHub's release tool.</li>
	<li><em>Hotfix</em> branches are used to fix bugs in released software that must be corrected before the next Release<ul>
		<li>check out from the tag of the release to be fixed
			(<span class="mono">git checkout tags/&lt;targetVersionTag&gt; -b hotfix-&lt;versionNum&gt;)</span></li>
	</ul></li>
	<li><em>Branch Naming Convention</em><ul>
		<li>(release|hotfix)-&lt;PR&gt;-&lt;issueNum&gt;-shortDesc;
			&lt;issueNum&gt; uses <a href="https://semver.org/#semantic-versioning-200">semantic versioning</a></li>
	</ul></li>
	<li><a href="#WorkflowIntelliJ">Workflow: IntelliJ</a> describes our procedures for developing branches.</li>
</ul><!-- Branch Types -->

<!-- @marker "Release Management" -->
<h4>Release Management</h4><ul>
	<li>GitHub Release tool<ul>
		<li>actual release for public projects, with option to tag as pre-release</li>
		<li>revision, including resources, created in GitHub; add resources, information, ...</li>
		<li>GitHub release stores description for potential users</li>
		<li>attached GitHub milestones store a technical summary</li>
	</ul></li>
	<li>Release Branch<ul>
		<li>Once the release branch has been created, we update ("bump") the version number.</li>
		<li>Work from the release branch is merged into master when the release branch is tagged and closed.</li>
	</ul></li>
</ul><!-- Release Management -->

<h4>Xcode-related projects</h4><ul>
	<li>AppCode projects are dependent on Xcode's project format, so projects in Objective-C/C++ are first created in Xcode.<ul>
		<li>issues with Xcode/AppCode projects<ul>
			<li>uses Xcode-specific project type<ul>
				<li>makes other project types unavailable</li>
			</ul></li>
			<li>Xcode interference: changes our configurations when it ie opened</li>
		</ul></li>
	</ul></li>
	<li>CLion><ul>
		<li>CLion is another JetBrains IDE for C/C++. Swift is available as a plugin.</li>
		<li>CLion uses CMake; projects have no connection with Xcode</li>
		<li>CLion does not have an editor for UI. We probably would use Sketch, which is intended for UI development.
			Sketch is highly rated, and our evaluation concurs.</li>
	</ul></li>
</ul><!-- Xcode-related projects -->

<h2 id="WorkflowIntelliJ">Workflows: IntelliJ with Terminal</h2>
<div style="page-break-before: always"></div>
<!-- @marker "Feature Branch Workflow" -->
<div class="wf-feature">
<h3 id='Feature_Branch_Workflow_'>Feature Branch Workflow</h3>
	<h5>Workflow Steps</h5><ul>
		<li id="ws_setBranch"><span class="step">Set Branch:</span> <span class="ital">set active branch; all UI views show target branch</span><ul>
			<li>set Task; Terminal: press "return" to show current branch; match Task, Terminal, and branch</li>
		</ul></li><!-- ws_setBranch -->
		<li id="ws_commit"><span class="step">Commit:</span> <span class="ital">all commits</span><ul>
			<li>use IntelliJ's commit (currently crK) for git message support</li>
		</ul></li><!-- ws_Commit -->
		<li id="ws_merge"><span class="step">Merge:</span> <span class="ital">merge another branch into current branch</span><ul>
			<li>preview: <span class='mono'><span class="prompt">$</span> git difftool HEAD origin</span>; then:<ul>
				<li>if indicated, handle some individual change groups first</li>
				<li>fetch/merge	<span class='mono'>(&nbsp;<span class="prompt">$&nbsp;</span>
					git fetch [-v] origin [--dry-run]; git merge --no-ff</span>)</li>
			</ul></li><!-- end Preview -->
			<li>to undo Merge if needed: <span class="mono"><span class="prompt">$ </span>git reflog</span>
				to identify previous entry as target SHA-1;
				<span class="mono"><span class="prompt">$ </span>git reset --merge &lt;target&gt;</span></li><!-- end undo-->
		</ul></li><!-- end Merge-->
		<li id="ws_push"><span class="step">Push:</span>  <span class="ital">push current local branch to its remote</span><ul>
			<li>fetch; [merge if changed]; push</li>
		</ul></li><!-- end Push -->
	</ul><!-- end Workflow Steps -->
	<h5>Processes</h5><ul>
		<li id="ws_SyncMaster"><span class="step">Sync Master:</span> <span class="ital">synchronize local and remote master branches</span><ul>
			<li><span class="step"><a href="#ws_setBranch">Set Branch</a> master</span>;
				fetch/<span class="step"><a href="#ws_merge">merge</a></span> origin/master;
				test; commit; <span class="step"><a href="#ws_push">push</a></span> master;
				[ gd origin origin/master ] (should be empty)</li>
		</ul></li><!-- ws_SyncMaster -->
		<li id="ws_UpdateBranch"><span class="step">Update Branch:</span> <span class="ital">update branch with changes from master</span> <ul>
			<li><span class="step"><a href="#ws_SyncMaster">Sync Master</a></span>;
				<span class="step"><a href="#ws_setBranch">Set Branch</a> &lt;target&gt;</span>;
				merge in master; test; <span class="step"><a href="#ws_push">push</a></span> &lt;target&gt;;
				[ gd -- origin/target ]</li>
		</ul></li><!-- Update Branch -->
		<li id="ws_MergeBranch"><span class="step">Merge Branch:</span> <span class="ital">merge branch into main line of development</span><ul>
			<li><span class="step"><a href="#ws_UpdateBranch">Update Branch</a></span>;
				<span class="step"><a href="#ws_setBranch">Set Branch</a> master</span>; test;
				merge in branch; test; <span class="step"><a href="#ws_push">push</a> master</span>
			</li>
		</ul></li><!-- ws_MergeBranch -->
	</ul><!-- Processes -->

<h4>While Issue Not Complete &nbsp;&nbsp;<span class='wf-developStart'>&lt;== start here</span></h4>
	<h5>While Task(s) Not Complete</h5>
		<div class="wf-openTask">
			<h6>OpenTask</h6><ul>
				<li>verify no pending changes; clean up stashes</li>
				<li><strong>New Task</strong>: <span class="step"><a href="#ws_SyncMaster">Sync Master</a></span>;
					new task from master with branch, task name &lt;productID&gt;-&lt;issueID&gt;-short-desc; test;
					<span class="step"><a href="#ws_push">push</a></span></li>
				<li>or <strong>Existing Task</strong>: switch to task; <span class="step"><a href="#ws_UpdateBranch">Update Branch</a>;
					</span>commit; test; <span class="step"><a href="#ws_push">push</a></span></li>
			</ul><!-- wf-openTask -->
		</div>
	</div>
	<div class="indent2">
		<div class="wf-developCommit">
			<h6><a id="wf_Develop">Develop/Commit</a></h6><ul>
				<li>repeat to push:<ul>
					<li>repeat to stage / commit:<ul>
						<li><span class="step"><a href="#ws_setBranch">Set Branch</a></span> &lt;target&gt;</li>
						<li>test/develop; inspect; diff modifications; [ stage files ]</li>
					</ul></li>
					<li class="like-h6" id='wf_Commit'>Commit<ul><!-- \todo fix 'like-h6' -->
						<li><span class="step"><a href="#ws_setBranch">Set Branch</a></span> &lt;target&gt;</li>
						<li>inspect; test; view local changes; commit<ul>
							<li>OR, for large and/or complicated commit: <span>git stash; git diff stash</span></li>
						</ul></li>
					</ul></li>
				</ul></li>
			</ul>
			<h6><a id="wf_push">Push / Review</a></h6><ul>
				<li><span class="step"><a href="#ws_push">push</a></span>; <span class="step"><a href="#ws_UpdateBranch">Update Branch</a></span>;
					<a href="#TriggerReview_">Trigger Review</a> as indicated
				</li>
			</ul>
		</div><!-- wf-developCommit -->
	</div><!-- indent2 -->
	<div class='indent'>
		<div class="wf-publish">
			<h6>Publish</h6><ul>
				<li>check for stashes, todo's; if [ (?)incomplete commit | stashes | todo's | settings to export ]: address as indicated</li>
				<li><span class="step"><a href="#ws_setBranch">Set Branch</a></span> &lt;target&gt;</li>
				<li>show status of all active local branches:&nbsp;&nbsp;<span class='mono'><span class="prompt"> $ </span>git branch -vv</span></li>
				<li>check commits to be merged:&nbsp;&nbsp;<span class='mono'><span class="prompt">$ </span>git cherry -v origin/master</span></li>
				<li><span class="step"><a href="#ws_MergeBranch">Merge Branch</a></span></li>
				<li>[verify :&nbsp;&nbsp;<span class='mono'><span class="prompt">$ </span>git cherry -v origin/master</span>]</li>
				<li>[gd &lt;branch&gt; &lt;origin/branch&gt;] delete local branch</li>
				<li><span class="step"><a href="#ws_setBranch">Set Branch</a></span> master</li>
				<li>[Backup Database with suffix &lt;id&gt;-&lt;issuenum&gt;-&lt;date&gt;]</li>
			</ul>
		</div><!-- wf-publish --></div>
		<div class="wf-triggerReview">
			<h6><a id="TriggerReview_">Trigger Review</a></h6><ul>
				<li>check git status, log</li>
				<li>UpSource: select commit; trigger review</li>
			</ul>
	</div><!-- indent -->
	<h5>[Archive Repository]</h5>

<!-- wf-feature -->

<div style="page-break-before: always"></div>
<h3 id="CodeReview">Code Review</h3><div class="wf-Review">
	<h5>Review</h5><ul>
		<li>review code, adding issues as indicated<ul>
			<li>Evaluate completeness of solution as specified.</li>
			<li>Evaluate completeness of automated and, if required, manual testing</li>
			<li>Verify test completeness and results.</li>
			<li>Check documentation that should have been updated.r</li>
			<li>Review code for cleanness, refactoring opportunities, ...</li>
		</ul></li>
	</ul>
	<h6>Code Review Complete: Close Issue</h6><ul>
		<li>test; check for unmerged  branches, pending stashes</li>
		<li>if task and issue complete; close issue; delete task and local branch</li>
		<li>address any unmerged branches and/or pending stashes</li>
	</ul>
</div><!-- wf-Review -->

<!-- @marker "Release and Hotfix Branches" -->
<div style="background-color: #e2faff">
<h3 id='Release_Hotfix_Workflow_' class="wf-release-hotfix">Release and Hotfix Workflow</h3>
	<div class="wf_release-hotfix">
	<h6><span class="warning">CAUTION: This workflow is tentative; we have not yet done these procedures</span></h6>
		<h5><a name="wf_release-hotfix">Release or Hotfix Branch</a></h5>
		<div class="wf-createRelease">
			<h6>Clean Up Branches</h6><ul>
				<li>cleanup existing branches and stashes<ul>
					<li>stash any other active branches</li>
				</ul></li>
			</ul><!-- end Clean Up Branches -->
			<h6>Set Up Revision</h6><ul>
				<li>Release Branch<ul>
					<li>select semantic version number/name, eg. v1.0.1</li>
				</ul></li>
				<li>Hotfix Branch<ul>
					<li>create 'release-&lt;versionName&gt;' based on tag where issue first appears</li>
					<li>ensure parent branch is checked out<ul>
						<li>if parent is not master, use <span class="mono">git checkout -b release-&lt;versionName&gt; &lt;parentTag&gt;</span></li>
					</ul>
					<li>cycles <a href="#wf_Develop">Develop</a> as indicated to fix</li>
				</ul></li>
			<li>GitHub: from repository's Code tab, select "&lt;n&gt; releases"; create and save draft of revision &lt;versionName&gt;</li>
			<li>add milestone 'v&lt;versionNum&gt;'; describe Revision goal in milestone text</li>
		</ul>
		</div>
	</div><!-- wf_release-hotfix -->
	<div class="wf-bump-version"><ul>
		<li>add result of <span class="mono">git cherry -v &lt;mostRecentTag&gt; to release milestone</span></li>
		<li>bump version: change all version numbers that appear in product<ul>
			<li>change version numbers in most project files</li>
			<li>(continue)</li>
		</ul></li>
		<li>commit ("bump version to &lt;versionName&gt;"); push</li>
		<li>Git &gt; tag &lt;versionName&gt;"; push branch and tags</li>
	</ul>
	<li><span class="bold-italic">versionName is now 'v&lt;versionNum&gt;'</span></li>
	<div class="wf-publish"><ul>
		<li>Publish<div class="wf-close"><ul>
			<li>update master from release</li>
			<li>master branch; merge in tagged release branch; test; [commit]; PUSH</li>
			<li>GitHub: from draft of Release: add product if indicated; publish</li>
			<li>delete branch: <span class="step">set tb=targetBranch</span> <span class="step">git branch -d $tb</span>
				<span class="step">git push origin --delete $tb</span></li>
		</ul></li>
	</div><!-- wf-publish -->
	<h5>[ Archive Repository ]</h5>

<div style="page-break-before: always">
	<!-- @marker "Workflow Subtasks" -->
	<h3>Workflow Subtasks</h3>
	<!-- @topicList "Workflow Subtasks" "workflowSubtasks" -->
		<!-- @topicItem "Naming Conventions" "#namingConventions" "0" "" -->
		<!-- @topicItem "Commit Message Conventions" "#commitMessageConventions" "0" "" -->
		<!-- @topicItem "Compare Revisions" "#adminCompareRevisions" "0" "" -->
		<!-- @topicItem "Compare Ancestry" "#adminCompareAncestry" "0" "" -->
		<!-- @topicItem "Bash Debug Logging" "#adminDebugLogging" "0" "" -->
		<!-- @topicItem "Resolve Conflicts" "#adminResolveConflicts" "0" "" -->
		<!-- @topicItem "Fix Divergent Branches" "#adminFixDivergentBranches" "0" "" -->
		<!-- @topicItem "Checkout Remote Branch" "#CheckoutRemoteBranch_" "0" "" -->
		<!-- @topicItem "Checkout from Stash" "#CheckoutFromStash" "0" "" -->
		<!-- @topicItem "Rebase Commits" "#RebaseCommits" "0" "" -->
		<!-- @topicItem "emacs Commands" "#emacsCommands" "0" "" -->
	<!-- @/topicList -->
	</div>

	<div style="background-color: #deedf8">
		<!-- @marker "Naming Conventions" -->
		<h6 id='namingConventions'>Naming Conventions</h6><ul>
			<li>feature branches and associated tasks: &lt;task-desc&gt;-#&lt;issueNum&gt;</li>
			<li>release branches and associated tasks: <span class="mono">release-v&lt;versionNum&gt;</span></li>
			<li>hotfix branches and associated tasks: <span class="mono">hotfix-v&lt;versionNum&gt;</span></li>
		</ul><!-- Naming Conventions -->

		<!-- @marker "Commit Message Conventions" -->
		<h6 id='commitMessageConventions'>Commit Message Conventions</h6><ul>
			<li><em>actions are taken based on some appearances of issueIDs in commit messages</em></li>
			<li>to close associated issue: add (close | fix | resolve)#&lt;issueID&gt; to commit message</li>
			<li>to connect to another issue: connect#&lt;ID&gt;</li>
		</ul><!-- Commit Message Conventions -->


		<h6 id='adminCompareRevisions'>Compare Revisions</h6><ul>
			<li><span class='em'>Compare</span>: (<span class='mono'>difftool --name-status first..second; lg first..second</span>)</li>
		</ul><!-- Compare Revisions -->

		<h6 id='adminCompareAncestry'>Compare Ancestry</h6><ul>
			<li><span class='em'>Ancestry</span>: (<span class='mono'>difftool --name-status first...second; lg first..second</span>)</li>
			<li class='ital'>difference between Compare Revisions and Compare Ancestry is the extra dot in difftool for Ancestry</li>
		</ul><!-- adminCompareAncestry -->

		<h6 id="adminDebugLogging">Bash Debug Logging</h6><ul>
			<li>add logger Live Template to code: `logger "$0#$LINENO: | #"`</li>
			<li>enter information to be logged at cursor, &lt;logtag&gt; content after '#'</li>
			<li>run code to make entries in syslog</li>
			<li>Terminal: <span class="mono">syslog | grep "#&lt;logtag&gt;"</span> to display tagged information</li>
		</ul><!-- Logging -->

		<h6 id='adminResolveConflicts'>Resolve Conflicts</h6><ul>
			<li>status</li>
			<li>if conflicts: <span class='mono'>merge resolve</span> (mergetool), saving successfully merged files<ul>
				<li>to choose one file, use <span class='mono'>checkout --[ours | theirs]</span> for local or merge target, respectively</li>
			</ul></li>
			<li class='ital'>if fetchup merge fails, could try: <span class='mono'>git rebase --preserve-merges @{u}</span></li>
			<li><span class='mono'>commit / resolve merge</span></li>
			<li>OR to undo merge: <span class='mono'>git merge --abort</span></li>
			<li>to recover corrupted project file: close in Xcode; diff fileMerge with previous good copy; edit manually</li>
		</ul>

		<!-- @marker "adminFixDivergentBranches" -->
		<h6 id='adminFixDivergentBranches'>Fix Divergent Branches</h6><ul>
			<li>use 'git rebase'</li>
		</ul>

		<!-- @marker "Checkout Remote Branch" -->
		<h6 id='CheckoutRemoteBranch_'>Checkout Remote Branch</h6><ul>
			<li>git checkout -b &lt;branchName&gt; origin/&lt;branchName&gt;</li>
		</ul>

		<!-- @marker "Checkout Stash as Branch" -->
		<h6 id='CheckoutFromStash'>Checkout from Stash</h6><ul>
			<li><span class="mono">git stash branch &lt;branchname&gt; [@stash{n}]</span>&nbsp;&nbsp;# checkout stash to branch</li>
			<li><span class="mono">git checkout stash@{0} -- &lt;filename&gt;</span>&nbsp;&nbsp;# checkout single file</li>
		</ul>

		<!-- @marker "Rebase Commits" -->
		<h6 id='RebaseCommits'>Rebase Commits</h6><ul>
			<li><strong>-- ONLY for commits that have not been pushed</strong></li>
			<li class="mono">git rebase -i HEAD~&lt;#commits&gt;</li>
			<li>edit commands (pick, squash, reword, ...); save<ul>
				<li>for reword: edit messages as they are shown</li>
				<li>for rebase:<ul>
					<li>git rebase --continue</li>
					<li>edit comment; save</li>
				</ul></li>
			</ul></li>
		</ul>

		<!-- @marker "emacs Commands" -->
		<h6 id='emacsCommands'>emacs Commands</h6><ul>
			<li>save: rX-S; exit: rX-rC; kill: rK</li>
			<li>cut: rW; copy: oW; paste: rY</li>
		</ul>

	</div></div>

<!-- @marker "Git Tasks" -->
<div style="page-break-before: always"></div>
<h2>Git Tasks</h2>
<!-- @topicList "Git Tasks" "GitTasks_" -->
	<!-- @topicItem "NewRepo" "#tsk_NewRepo" "0" "" -->
	<!-- @topicItem "Branch" "#tsk_Branch" "1" "" -->
	<!-- @topicItem "Master Branch" "#tsk_MasterBranch" "1" "" -->
	<!-- @topicItem "Stash" "#tsk_Stash" "1" "" -->
	<!-- @topicItem "Cherry" "#tsk_Cherry" "1" "find commits not in branch" -->
	<!-- @topicItem "Diff" "#tsk_Diff" "1" "" -->
	<!-- @topicItem "Commit" "#tsk_Commit_" "1" "" -->
	<!-- @topicItem "Tag" "#tsk_Tag" "1" "" -->
	<!-- @topicItem "Remove Repository File(s)" "#Remove_Repository_File_" "1" "" -->
	<!-- @topicItem "Bisect" "#tsk_Bisect" "1" "" -->
	<!-- @topicItem "Information" "#tsk_Information" "1" "" -->
	<!-- @topicItem "Undo" "#tsk_Undo" "1" "" -->
	<!-- @topicItem "Fix Line Endings" "#tsk_FixLineEndings" "1" "" -->
<!-- @/topicList -->

<!-- @marker "NewRepo" -->
<h4 id="tsk_NewRepo">NewRepo</h4><div class="indent">
	<h5>create and clone initial repo</h5><ul>
		<li class="mono">git remote add origin https://github.com/&lt;userName&gt;/&lt;projectName&gt;.git</li>
		<li class="mono">cd &lt;parentFolderForNewRepo&gt;</li>
		<li class="mono">git clone https://github.com/&lt;userName&gt;/&lt;projectName&gt;.git</li>
	</ul>
	<h5>add readme file</h5><ul>
		<li class="mono">echo "# &lt;repoName&gt;" &gt; README.md</li>
		<li class="mono">git add --all</li>
		<li class="mono">git commit -m "initial commit"</li>
	</ul>
	<h5>add license, normally MIT</h5><ul>
		<li>GitHub, from main page of new repository: Create new file named LICENSE or LICENSE.md</li>
		<li>select 'Choose a license template'; select license; 'Review and submit'</li>
		<li class="mono">git commit -m "add &lt;licenseType&gt; license"</li>
	</ul>
	<h5>push</h5><ul>
		<li class="mono">git push -u origin master</li>
	</ul>
</div>

<!-- @marker "Branch" -->
<h4 id="tsk_Branch">Branch</h4><ul>
	<li><span class='mono'>git branch</span>&nbsp;&nbsp;# to list current branches<ul>
		<li><span class='mono'>--remotes</span>&nbsp;&nbsp;# to list remote branches</li>
		<li><span class='mono'>--all</span>&nbsp;&nbsp;# to list both local and remote branches</li>
		<li><span class='mono'>--no-merged</span>&nbsp;&nbsp;# check for unmerged branches</li>
		<li><span class='mono'>--move [&lt;oldbranch&gt;] &lt;newbranch&gt;</span>&nbsp;&nbsp;# to rename a branch<ul>
			<li>then, to rename remote branch to match:<ul>
				<li class='blurb'>this assumes remote branch is named 'origin'; can use <span class='mono'>git remote -v</span> to verify</li>
				<li><span class='mono'>git push origin :&lt;oldBranch&gt;&nbsp;&nbsp;# delete old remote branch</span></li>
				<li><span class='mono'>git push --set-upstream origin &lt;newBranch&gt;&nbsp;&nbsp;# recreate remote branch with new name</span></li>
			</ul>
		</li>
		</ul></li>
		<li><span class='mono'>--delete &lt;branchname&gt;</span>&nbsp;&nbsp;# delete a branch<ul>
			<li class='blurb'>also see git docs for information about deleting and cleaning up remote branches</li>
		</ul></li>
	</ul></li>
	<li><span class='mono'>git checkout -b &lt;new-branch&gt; [&lt;start_point&gt;]</span>&nbsp;&nbsp;# move existing work to a new branch, rooted at commit &lt;start_point&gt; if specified</li>
	<li>list branches by date:&nbsp;&nbsp;<span class='mono'>
			<span class="prompt">$ </span>for k in `git branch | sed s/^..//`; do echo -e `git log -1 --pretty=format:"%Cgreen%ci %Cblue%cr%Creset" $k --`\\t"$k";done | sort</span></li>
</ul>

<!-- @marker "Master Branch" -->
<h4 id="tsk_MasterBranch">Master Branch</h4>
	<h5><a id="tsk_MergeMaster">Merge Master</a></h5><ul>
		<li class="blurb">used with Xcode; otherwise, AppCode's own merge is used</li>
		<li>checkout branch; set $cb; show --name-status; <a href="#adminCompareAncestry"><span class='em'>Ancestry</span></a> $cb.master</li>
		<li>if changed:<ul>
			<li>merge mergeMaster <span class='mono'>(--no-ff -m "merge master")</span>; status; <a href="#adminResolveConflicts"><span class='em'>Resolve Conflicts</span></a></li>
			<li>test; show; <a href="#adminCompareRevisions"><span class='em'>Compare</span></a> origin/$cb.$cb; push</li>
		</ul></li>
	</ul>

	<h5><a id="tsk_UpdateMaster">Update Master</a></h5><ul>
		<li class="blurb">not needed for now; purpose is to update our code with work from others</li>
		<li>checkout master; verify status clean</li>
		<li>fetch updates (<span class='mono'>git remote update --prune</span>); status</li>
		<li>if changed: merge updateMaster (<span class='mono'>git merge --ff-only @{u}</span>)</li>
		<li><a href="#adminResolveConflicts"><span class='em'>Resolve Conflicts</span></a>; test; push</li>
	</ul>

<!-- @marker "Stash" -->
<h4 id="tsk_Stash">Stash</h4><ul>
	<li><span class='mono'>git stash save &lt;name&gt;</span>&nbsp;&nbsp;# save stash named &lt;name&gt;; leave working directory clean<ul>
		<li><span class='mono'>add --keep-index</span>&nbsp;&nbsp;# to leave all changes already added to the index intact</li>
	</ul></li>
	<li>apply:<ul>
		<li><span class='mono'>git stash apply</span>&nbsp;&nbsp;# to apply the top stash to the current working copy</li>
		<li><span class='mono'>git stash branch</span>&nbsp;&nbsp;# to apply the top stash to a new branch based in the stash's base revision</li>
		<li><span class='mono'>git checkout stash@{n} -- &lt;filename&gt;</span>&nbsp;&nbsp;# to checkout a single file from a stash</li>
		<li>add <span class='mono'>stash@{&lt;index&gt;}</span>&nbsp;&nbsp;#  to specify a different stash</li>
	</ul></li>
	<li><span class='mono'>git stash list</span>&nbsp;&nbsp;# list all stashes in repository</li>
	<li><span class='mono'>git stash drop</span>&nbsp;&nbsp;# remove the specified stash</li>
	<li><span class='mono'>git stash show [stash@{n}]</span>&nbsp;&nbsp;# show details for the top or a specified stash</li>
</ul>

<!-- @marker "Cherry" -->
<h4 id="tsk_Cherry">Cherry</h4><ul>
	<li><span class="mono">git cherry</span>&nbsp;&nbsp;# list commits not included in current branch<ul>
		<li><span class="mono">-v </span>&nbsp;&nbsp;# include commit message in output</li>
		<li><span class="mono">&lt;branchName&gt;</span>&nbsp;&nbsp;# commits not included in specified branch</li>
	</ul></li>
</ul>

<!-- @marker "Diff" -->
<h4 id="tsk_Diff">Diff</h4>
	<h5>Diff Commands</h5><ul>
		<li><span class='mono'>git diff</span>&nbsp;&nbsp;# working copy and index (unstaged)</li>
		<li><span class='mono'>git diff --cached</span>&nbsp;&nbsp;# index and last commit (staged)</li>
		<li><span class='mono'>git diff HEAD</span>&nbsp;&nbsp;# working directory since your last commit (unstaged and staged)</li>
		<li><span class='mono'>git diff &lt;branch&gt;</span>&nbsp;&nbsp;# working copy and another branch</li>
		<li><span class='mono'>git diff &lt;branch1&gt;..&lt;branch2&gt;</span>&nbsp;&nbsp;# tips of the two branches</li>
		<li><span class='mono'>git diff &lt;branch1&gt;...&lt;branch2&gt;</span>&nbsp;&nbsp;# from their common ancestor to branch</li>
		<li><span class='mono'>git difftool &lt;arguments as above&gt;</span>&nbsp;&nbsp;# display results using FileMerge</li>
	</ul>
	<h5>Diff Options</h5><ul>
		<li><span class='mono'>-- ./path</span>&nbsp;&nbsp;# restrict to a path</li>
		<li><span class='mono'>--name-status</span>&nbsp;&nbsp;# one line per file (like svn status)</li>
		<li><span class='mono'>--pretty=oneline</span>&nbsp;&nbsp;# to show just sha and one-line comment</li>
		<li><span class='mono'>--graph</span>&nbsp;&nbsp;#  to show branch relationships<ul>
			<li>with <span class='mono'>--topo-order</span>&nbsp;&nbsp;# shows top-down so tree is clearer</li>
		</ul></li>
		<li><span class='mono'>--date-order</span>&nbsp;&nbsp;# to show chronologically</li>
	</ul>
	<h5>diff a previous version of a file</h5><ul>
		<li><span class='mono'>git lg --follow &lt;filename&gt;</span>&nbsp;&nbsp;# show changes to this file</li>
		<li><span class='mono'>st=&lt;shaTag&gt;</span>&nbsp;&nbsp;# set tag to target sha</li>
		<li><span class='mono'>git show --name-only &lt;shaTag&gt; </span>&nbsp;&nbsp;# see commit message; get file path<ul>
			<li>if file path is the same as current path:<ul>
				<li><span class='mono'>git difftool &lt;shaTag&gt; &lt;filename&gt;</span>&nbsp;&nbsp;# diff revisions</li>
			</ul></li>
			<li>else<ul>
				<li><span class='mono'>git checkout &lt;shaTag&gt; &lt;filename&gt;</span>&nbsp;&nbsp;# checkout file to compare</li>
				<li>use BBEdit to compare files</li>
			</ul></li>
		</ul></li>
	</ul>

<!-- @marker "Commit" -->
<h4 id="tsk_Commit_">Commit</h4><ul>
	<li class="blurb">Commit from Terminal when committing cached items only, which IntelliJ platform does not support.</li>
	<li>diff between branch and cached files:&nbsp;&nbsp;<span class='mono'><span class="prompt">$ </span>git difftool --cached (gdc)</span></li>
	<li>edit TextEdit file "${CCDev}/tmp/msg.txt" to contain git message</li>
	<li>dry-run commit:&nbsp;&nbsp;<span class='mono'><span class="prompt">$ </span>git commit --dry-run [--amend] -F ${CCDev}/tmp/msg.txt</span></li>
	<li>commit:&nbsp;&nbsp;<span class='mono'><span class="prompt">$ </span>git commit [--amend] -F ${CCDev}/tmp/msg.txt</span></li>
	<li>before pushing, diff log of this commit from IDE</li>
</ul>

<!-- @marker "Tag" -->
<h4 id="tsk_Tag">Tag</h4><ul>
	<li><span class='mono'>git tag</span>&nbsp;&nbsp;# list<ul>
		<li><span class='mono'>-l</span>&nbsp;&nbsp;# to match a pattern</li>
	</ul></li>
	<li><span class='mono'>git tag -a &lt;tag&gt; -m '&lt;msg&gt;'</span>&nbsp;&nbsp;# create</li>
	<li><span class='mono'>git tag -d &lt;tag&gt;</span>&nbsp;&nbsp;# delete</li>
	<li><span class='mono'>git tag &lt;new&gt; &lt;new&gt;;git tag -d &lt;old&gt;; git push origin :&lt;old&gt;; git push --tags</span>&nbsp;&nbsp;# rename</li>
	<li><span class='mono'>git ls-remote --tags origin</span>&nbsp;&nbsp;# list remote tags</li>
	<li><span class='mono'>git show &lt;tag&gt;</span>&nbsp;&nbsp;# show information about &lt;tag&gt;</li>
	<li><span class='mono'>git push --tags</span>&nbsp;&nbsp;# push tags</li>
	<li><span class="mono">&lt;sha&gt;</span>&nbsp;&nbsp;# add to select another commit</li>
</ul>

<!-- @marker "Remove Repository File(s)" -->
<h4 id='Remove_Repository_File_'>Remove Repository File(s)</h4><ul>
	<li><span class='mono'>git rm --cached &lt;filename&gt;</span>&nbsp;&nbsp;# remove file</li>
	<li><span class='mono'>git rm --cached -r &lt;directory&gt;</span>&nbsp;&nbsp;# remove directory</li>
</ul>

<!-- @marker "Bisect" -->
<h4 id='tsk_Bisect'>Bisect</h4><ul>
	<li><span class='mono'>git checkout -b &lt;newbranch&gt;</span>&nbsp;&nbsp;# checkout a new branch<ul>
		<li><strong>Detached Head</strong><ul>
			<li>If accidentally done from the master branch, a detached head is possible. Correct by checking the work out into  new branch, which restores master to its previous state.</li>
		</ul></li>
	</ul></li>
	<li><span class='mono'>git bisect start</span>&nbsp;&nbsp;# start a bisect operation<ul>
		<li class='blurb'>then execute <span class='mono'>good</span> and <span class='mono'>bad</span> to establish range</li>
	</ul></li>
	<li><span class='mono'>git bisect bad</span>&nbsp;&nbsp;# mark current bisect commit as bad</li>
	<li><span class='mono'>git bisect good</span>&nbsp;&nbsp;# mark current bisect commit as good</li>
	<li><span class='mono'>git bisect skip</span>&nbsp;&nbsp;# skip current bisect commit</li>
	<li><span class='mono'>git bisect reset</span>&nbsp;&nbsp;# clean up from a bisection</li>
	<li><span class='mono'>git bisect log</span>&nbsp;&nbsp;# show log of current bisection</li>
	<li><span class='mono'>git bisect replay</span>&nbsp;&nbsp; &lt;logfile&gt; # replay bisection from edited log output &lt;logfile&gt;</li>
</ul>

<!-- @marker "Information" -->
<h4 id="tsk_Information">Information</h4>
	<h5>Log Commands</h5><ul>
		<li><span class='mono'>git log &lt;tag&gt;..</span>&nbsp;&nbsp;# commits since (not reachable from) &lt;tag&gt;</li>
		<li><span class='mono'>git log &lt;branch&gt;..master</span>&nbsp;&nbsp;# commits reachable from master but not &lt;branch&gt;</li>
		<li><span class='mono'>git log master..&lt;branch&gt;</span>&nbsp;&nbsp;# commits reachable from &lt;branch&gt; but not master</li>
		<li><span class='mono'>git log master...&lt;branch&gt;</span>&nbsp;&nbsp;# commits reachable from either &lt;branch&gt; or master, but not both</li>
		<li><span class='mono'>git log &lt;folder&gt;/</span>&nbsp;&nbsp;# commits that modify any file under &lt;folder&gt;/</li>
		<li><span class='mono'>git lg</span>&nbsp;&nbsp;# in-house alias to display single-line log output</li>
	</ul>
	<h5>Log Options</h5><ul>
		<li><span class='mono'>git log --since="2 weeks ago"</span>&nbsp;&nbsp;# commits from the last 2 weeks</li>
		<li><span class='mono'>git log &lt;filename&gt;</span>&nbsp;&nbsp;# commits that modify &lt;filename&gt;</li>
		<li><span class='mono'>git log -S'&lt;pattern&gt;'</span>&nbsp;&nbsp;# commits that add or remove any file data matching the string '&lt;pattern&gt;'</li>
		<li><span class='mono'>git log --no-merges</span>&nbsp;&nbsp;# skip merge commits</li>
		<li><span class='mono'>git log --follow</span>&nbsp;&nbsp;# follow file through renames if any</li>
	</ul>
	<h5>Other Information Commands</h5><ul>
		<li><span class='mono'>git ls-files --other --exclude-standard</span>&nbsp;&nbsp;# untracked files</li>
		<li><span class='mono'>git branch --no-merged</span>&nbsp;&nbsp;# check for unmerged branches</li>
		<li><span class='mono'>git reflog [log options | with dates(custom)]</span>&nbsp;&nbsp;# show reflog</li>
	</ul>

<!-- @marker "Fix Line Endings" -->
<h4 id='tsk_FixLineEndings'>Fix Line Endings</h4><ul>
	<li class='blurb'>for fixing line endings when adding files from an external source<ul>
		<li>see <a href="http://help.github.com/articles/dealing-with-line-endings/">GitHub: Dealing With Line Endings</a></li>
		<li>We used a slightly modified version of this technique when importing the pyparser script and its support. It seems to have worked fine, although after the reset step there were no files to add, and we were done.</li>
		<li>These steps show what we actually planned/did.</li>
	</ul></li>
	<li>checkin the files</li>
	<li>remove files from working tree and index: <span class='mono'>git rm --cached -r &lt;pathnames, eg. fldr/*&gt;</span></li>
	<li>rewrite the files back, with corrected line endings: <span class='mono'>git reset --hard</span></li>
	<li>if necessary:<ul>
		<li>add the files back into the index: <span class='mono'>git add --all</span><ul>
			<li class='blurb'>messages "warning: CRLF will be replaced by LF in file." are ok</li>
		</ul></li>
		<li><span class='mono'>git commit -m "normalize line endings"</span></li>
	</ul></li>
</ul>

<!-- @marker "Undo" -->
<h4 id="tsk_Undo">Undo</h4><ul>
	<li><span class='mono'>git checkout -- &lt;file&gt;</span>&nbsp;&nbsp;# restore one file to version in index</li>
	<li><span class='mono'>git checkout HEAD &lt;file&gt;</span>&nbsp;&nbsp;# restore one file to version in HEAD revision</li>
	<li><span class='mono'>git reset --soft HEAD@{1}</span>&nbsp;&nbsp;# undo last commit (set HEAD to point to parent of HEAD)</li>
	<li><span class='mono'>git reset --mixed HEAD@{1} (default)</span>&nbsp;&nbsp;# also update index to match new HEAD; same as unstaging everything</li>
	<li><span class='mono'>git revert [HEAD|&lt;commit&gt;]</span>&nbsp;&nbsp;# creates a new commit that undoes the most recent or a previous commit</li>
	<li><span class='mono'>git reflog; git checkout &lt;sha&gt;; git checkout -b &lt;branch&gt;</span> find and restore recently deleted branch</li>
	<li><a href="https://github.com/git/git/blob/master/Documentation/howto/revert-a-faulty-merge.txt">revert a faulty merge</a></li>
	<li><a href="https://github.com/blog/2019-how-to-undo-almost-anything-with-git">How to undo (almost) anything with Git</a></li>
	<li><span class='mono'>git reset --hard HEAD</span>&nbsp;&nbsp;# discard all changes since last commit; restores index and files; then:<ul>
		<li>master branch; make small change somewhere (ReadMe?); commit master branch; push master (requires -f?)</li>
		<li>rename branches between old and new heads to avoid accidental use<ul>
			<li>to determine which branches were affected by the reset (have commits between old and new heads): list branches by date of last commit:<ul>
				<li class="mono">for k in `git branch -r | perl -pe 's/^..(.*?)( ->.*)?$/\1/'`; do echo -e<br />
					`git show --pretty=format:"%Cgreen%ci %Cblue%cr%Creset" $k -- | head -n 1`\\t$k; done | sort -r</li>
			</ul></li>
			<li>for each branch to be renamed:<ul>
				<li>checkout branch; set $cb; checkout master</li>
				<li><span class="mono">git branch --move $cb inreset_$cb</span></li>
				<li>checkout $cb; <span class="mono">git push origin :$cb</span></li>
				<li><span class="mono">git push --set-upstream origin inreset_$cb</span></li>
			</ul></li>
		</ul></li>
	</ul></li>
	<li><strong>Recovering from Problem Branches</strong><ul>
		<li><em>Sometimes we must deal with branches that have content we want, but that also
			include bad changes, require a merge commit that is too complex to be safe...</em></li>
		<li><em>Our preferred strategy is to save both patches and a backup copies of the target files, and then
			try one strategy, with the other available if problems are encountered.</em></li>
		<li><strong>Recovery strategy</strong><ul>
			<li>for intended changes: leave the existing local branch in place, and probably push it<ul>
				<li><em>We consider all feature branches on the repo to be private,
					so there should be no work based on it. Also, for the foreseeable future,
					there are no other developers anyway.</em></li>
				<li>create new branch, and make the desired source code changes again</li>
			</ul></li>
		</ul></li>
		<li><strong>Procedure</strong><ul>
			<li>make backup copies of affected files</li>
			<li>determine revision &lt;sha&gt; to start with - a spot where master and branch match</li>
			<li>generate multiple patches for the problem branch<ul>
				<li>on problem branch: <span class="mono">git format-patch &lt;sha&gt;</span></li>
				<li>WARNING: If/when patches are applied, there must be NO CHANGES to any affected files
					from the time the patch files are generated and until the patches have all been applied.
					If changes are made, remaining patches will not apply cleanly, which will break the process.</li>
			</ul></li>
			<li>checkout master</li>
			<li>move HEAD to point to &lt;sha&gt;: <span class="mono">git reset --hard &lt;sha&gt;</span></li>
			<li>compare local master with origin/master to verify that local master is as expected</li>
			<li>commit and push master: <span class="mono">git push --force origin master</span></li>
			<li>IDEA: create new task based on *master* for the rebuilt branch</li>
			<li>on new branch, push: <span class="mono">git push --force origin &lt;branch&gt;</span></li>
			<li>choose: IDEA diff | git patch<ul>
				<li>IDEA diff<ul>
					<li>diff: target branch with tip of original branch<ul>
						<li>for each group of changes:<ul>
							<li>make changes by applying original branch changes to target branch</li>
							<li><a href='#wf_Commit'>commit</a></li>
						</ul></li>
					</ul></li>
				</ul></li>
				<li>git patch<ul>
					<li>for each patch, sequentially</li>
						<li>apply to new branch: <span class="mono">git apply &lt;patchNumber&gt;-*.patch</span><ul>
						<li>use diff from IDEA as indicated to examine and plan changes</li>
						<li>on receiving branch:<ul>
							<li>TextEdit: edit and save commit message in file <span class='mono'>${HOME}/Library/CCDev/tmp/msg.txt</span></li>
							<li>add selected hunks: <span class='mono'>git add [ -i | --interactive ]</span> (alias 'gai')<ul>
								<li>to undo: <span class='mono'>git reset &lt;filename&gt;</span></li>
							</ul></li>
							<li>view changes: <span class='mono'>git difftool --cached</span> (alias 'gdc')</li>
							<li><span class='mono'>cat ${HOME}/Library/CCDev/tmp/msg.txt</span> (alias gcsm)</li>
							<li><span class='mono'>git commit -F ~/Library/CCDev/tmp/msg</span>(alias gcmf)</li>
							<li>push</li>
						</ul></li>
						<li>repeat until all changes in this patch have been committed</li>
					<li>continue until all patches have been handled</li>
				</ul></li>
			</ul></li>
			<li><a href="http://candcsoft.com/TechnicalDocs/DevSupport/Git.html#merge_master_">merge master</a></li>
			<li><a href="http://candcsoft.com/TechnicalDocs/DevSupport/Git.html#publish_">publish</a> and continue</li>
		</ul></li>
	</ul></li>
</ul></li>
</ul>

<!-- @marker "References" -->
<h2 id='_References'>References</h2><ul>
	<li><a href="https://git-scm.com/docs/">Pro-Git</a></li>
	<li><a href="http://paul.stadig.name/2010/12/thou-shalt-not-lie-git-rebase-ammend.html">Paul Stadig: Thou Shalt Not Lie</a></li>
	<li><a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a> <span><em>gitflow</em></span></li>
	<li><a href="https://help.github.com/articles/creating-releases/">GitHub: Creating Release</a></li>
	<li><a href="https://help.github.com/articles/linking-to-releases/">GitHub: Linking to releases</a> </li>
	<li><a href="https://www.viget.com/articles/successful-release-management-and-how-to-communicate-about-it">Managing a Successful Release Process</a></li>
</ul>

<!-- @marker "Notes" -->
<h2>Notes</h2>
<!-- @topicList "Notes" "GitNotes_" -->
<!-- @/topicList -->

<ul>
	<li>rebase only to rebase an existing branch on more current code or clean up a current, unmerged branch; see <a href="http://paul.stadig.name/2010/12/thou-shalt-not-lie-git-rebase-ammend.html">Paul Stadig: Thou Shalt Not Lie</a></li>
	<li class='dq'>sha/date marker: used in history and thread files to support matching history with repository<ul>
		<li>Setting the sha/date marker replaces the clearly-visible (from source code) commit message and notes with the sha/date marker. A branch's sha/date is often updated from another branch.</li>
		<li><span class='mono'>print "[$(cd /Users/carolclark/Dev/${proj}; git log -1 --pretty=format:'%h') $(date +%m/%d/20%y) &lt;placeholder&gt;]"</span></li>
	</ul></li>
</ul>

<p>
config, admin only: git remote add remote /Volumes/carollclark/gitrep/PunkinRemote	# adds PunkinRemote as remote "remote"
to replace an existing working copy with a newly-cloned one, first remove the existing repository from Xcode's repository list, close the Xcode workspace, and quit Terminal (BBEdit project?)<br />
my working copy has a branch for Laura's stuff (she pushes to Remote; I integrate and push to Main)<br />
internal: threads; branches; compound (here or with source control?)<br />
git diff master origin/master (same as master..origin/master?)<br />
see git-rev-parse<br />
see <a href="http://grit.rubyforge.org/">grit</a> for ruby scripting<br />
</p>

<hr class='footer' />
<p class='footer'>Copyright 2011-16 by C &amp; C Software, Inc. All rights reserved.</p>
<p class='footer'>Confidential and Proprietary.</p>
</body>
</html>
