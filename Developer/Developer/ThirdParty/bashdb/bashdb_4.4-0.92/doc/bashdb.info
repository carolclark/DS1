This is bashdb.info, produced by makeinfo version 5.2 from bashdb.texi.

INFO-DIR-SECTION Programming & development tools.
START-INFO-DIR-ENTRY
* Bashdb - the bash debugger: (bashdb). The BASH debugger
END-INFO-DIR-ENTRY

This file documents the BASH debugger BASH.

   This is the 4.4-0.92 Edition, 7 July 2014, of 'Debugging with BASHDB:
the GNU Source-Level Debugger' for BASH

   Copyright (C) 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2011 Rocky
Bernstein for the Free Software Foundation.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.


File: bashdb.info,  Node: Top,  Next: Summary,  Prev: (dir),  Up: (dir)

Debugging with the BASH debugger
********************************

This file describes the BASH debugger, the BASH symbolic debugger.

   This is the 4.4-0.92 Edition, 7 July 2014, for BASH.

   Copyright (C) 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2011 Rocky
Bernstein

* Menu:

* Summary::                     Overview of Debugger with a sample session

* Invocation::                  Getting in and out
* Running::                     Script setup inside the BASH debugger
* Debugger Command Reference::  BASH debugger command reference

* BASH Debugger Bugs::          Reporting bugs
* History and Acknowledgments:: History and Acknowledgments

Appendices
* Copying::			GNU General Public License says
                                how you can copy and share bashdb
* GNU Free Documentation License::  The license for this documentation

Indexes (nodes containing large menus)
* Command Index::             An item for each command name.
* General Index::             An item for each concept.


File: bashdb.info,  Node: Summary,  Next: Invocation,  Up: Top

1 Summary of the BASH Debugger
******************************

The purpose of a debugger such as the BASH debugger is to allow you to
see what is going on "inside" a bash script while it executes.

   the BASH debugger can do four main kinds of things (plus other things
in support of these) to help you catch bugs in the act:

   * Start your script, specifying anything that might affect its
     behavior.

   * Make your script stop on specified conditions.

   * Examine what has happened, when your script has stopped.

   * Change things in your script, so you can experiment with correcting
     the effects of one bug and go on to learn about another.

   Although you can use the BASH debugger to debug scripts written in
BASH, it can also be used just as a front-end for learning more about
programming in BASH.  As an additional aid, the debugger can be used
within the context of an existing script with its functions and
variables that have already been initialized; fragments of the existing
can be experimented with by entering them inside the debugger.

* Menu:

* Sample Session::                    A Sample BASH Debugger session
* Interactive Line Tracing Session::  Interactive Line Tracing Session


File: bashdb.info,  Node: Sample Session,  Next: Interactive Line Tracing Session,  Up: Summary

1.1 A Sample BASH Debugger Session
==================================

You can use this manual at your leisure to read all about the BASH
debugger.  However, a handful of commands are enough to get started
using the debugger.  This chapter illustrates those commands.

   Below we will debug a script that contains a function to compute the
factorial of a number: fact(0) is 1 and fact(n) is n*fact(n-1).

     $ bashdb -L .  /tmp/fact.sh
     Bourne-Again Shell Debugger, release bash-4.4-0.92
     Copyright 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2011 Rocky Bernstein
     This is free software, covered by the GNU General Public License, and you are
     welcome to change it and/or distribute copies of it under certain conditions.

     (/tmp/fact.sh:9):
       9:	echo fact 0 is: `fact 0`
     bashdb<0> -
       1:    #!/usr/local/bin/bash
       2:    fact() {
       3:    ((n==0)) && echo 1 && return
       4:    ((nm1=n-1))
       5:    ((result=n*`fact $nm1`))
       6:    echo $result
       7:    }
       8:
       9:==> echo fact 0 is: `fact 0`
     bashdb<1> list
      10:   echo fact 3 is: $(fact 3)

   The command invocation uses the option "-L ."  Here we assume that
the 'bashdb' script and the debugger files are in the same location.  If
you are running from the source code, this will be the case.  However if
_bashdb_ has been installed this probably won't be true and here you
probably don't need to use "-L ."  Instead you would type simply 'bashdb
/tmp/fact.sh'.

   Position information consists of a filename and line number, e.g.
'(/tmp/fact.sh:9)' and is given parenthesis.  This position format is
similar to that used in a dozen or so other debuggers; GNU Emacs and DDD
can parse this format.

   In the first debugger command we gave '-', we listed a window of
lines _before_ where we were executing.  Because the window, 10 lines,
is larger than the number of lines to the top of the file we printed
only 9 lines here.  The next command, 'list', starts from the current
line and again wants to print 10 lines but because there are only one
remaining line, that is what is printed.

     bashdb<2> step
     (/tmp/fact.sh:9):
     fact 0
     9:	echo fact 0 is: `fact 0`
     bashdb<(3)> <RET>
     2:	fact() {
     bashdb<(4)> <RET>
     3:	((n==0)) && echo 1 && return
     bashdb<(5)> print $n

     bashdb<(6)>

   Ooops...  The variable 'n' isn't initialized.(1)

   The first 'step' command steps the script one instruction.  It may
seem odd that the line printed is exactly the same one as before.  What
has happened though is that we've "stepped" into the subshell needed to
run '`fact 0`'; we haven't however started running anything inside that
subshell yet though.

   To indicate that which piece of the multi-part line 'echo fact 0 is:
`fact 0`' we show that part all by itself 'fact 0'.  If nothing is shown
then it means we are running the beginning statement or in this case the
outermost statement.

   To indicate that we are now nested in a subshell, notice that the
command number, starting with 3, or the third command entered, now
appears in parenthesis.  Each subshell nesting adds a set of
parenthesis.

   The first 'step' command steps the script one instruction; it didn't
advance the line number, 9, at all.  That is because we were stopping
before the command substitution or backtick is to take place.  The
second command we entered was just hitting the return key; _bashdb_
remembers that you entered 'step' previously, so it runs the step rather
than 'next', the other alternative when you hit <RET>.  Step one more
instruction and we are just before running the first statement of the
function.

   Next, we print the value of the variable 'n'.  Notice we need to add
a preceding dollar simple to get the substitution or value of n.  As we
will see later, if the 'pe' command were used this would not be
necessary.

   We now modify the file to add an assignment to local variable 'n' and
restart.

     bashdb<6> restart
     Restarting with: /usr/local/bin/bashdb -L . fact.sh
     (/tmp/fact.sh:10):
     10:	echo fact 0 is: `fact 0`
     bashdb<0> list 1
       1:    #!/usr/local/bin/bash
       2:    fact() {
       3:    local -i n=${1:0}
       4:    ((n==0)) && echo 1 && return
       5:    ((nm1=n-1))
       6:    ((result=n*`fact $nm1`))
       7:    echo $result
       8:    }
       9:
      10:==> echo fact 0 is: `fact 0`
     bashdb<1> s 3
     (/tmp/fact.sh:3):
     3:	local -i n=${1:0}
     bashdb<(2)> step
     (/tmp/fact.sh:4):
     4:	((n==0)) && echo 1 && return
     bashdb<(3)> print $n
     print $n
     0

This time we use the 'list' debugger command to list the lines in the
file.  From before we know it takes three 'step' commands before we get
into the fact() function, so we add a count onto the 'step' command.
Notice we abbreviate 'step' with 's'; we could have done likewise and
abbreviated 'list' with 'l'.

     bashdb<(4)> <RET>
     (/tmp/fact.sh:4):
     4:	((n==0)) && echo 1 && return
     echo 1
     bashdb<(5)> <RET>
     (/tmp/fact.sh:4):
     4:	((n==0)) && echo 1 && return
     return

Again we just use <RET> to repeat the last 'step' commands.  And again
the fact that we are staying on the same line 4 means that the next
condition in the line is about to be executed.  Notice that we see the
command ('echo 1' or 'return') listed when we stay on the same line
which has multiple stopping points in it.  Given the information above,
we know that the value echo'ed on return will be 1.

     bashdb<(6)> <RET>
     fact 0 is: 1
     (/tmp/fact.sh:12):
     12:	echo fact 3 is: $(fact 3)
     bashdb<(7)> break 5
     Breakpoint 1 set in file fact.sh, line 5.
     bashdb<(8)> continue

We saw that we could step with a count into the function fact().
However above took another approach: we set a stopping point or
"breakpoint" at line 5 to get us a little ways into the fact()
subroutine.  Just before line 5 is to executed, we will get back into
the debugger.  The 'continue' command just resumes execution until the
next stopping point which has been set up in some way.

     (/tmp/fact.sh:5):
     5:      ((nm1=n-1))
     Breakpoint 1 hit(1 times).
     bashdb<(8)> x n-1
     2
     bashdb<(9)> s
     (/tmp/fact.sh:5):
     6:     ((result=n*`fact $nm1`))
     bashdb<(10)> c
     fact.sh: line 6: ((: result=n*: syntax error: operand expected (error token is "*")
     bashdb<(7)> R
     Restarting with: bash --debugger fact.sh
     11:	echo fact 0 is: `fact 0`
     bashdb<0> l fact
      2:    fact ()
      3:    {
      4:       local -i n=${1:0};
      5:       (( "n==0" )) && echo 1 && return;
      6:       (( nm1=n-1 ));
      7:       ((fact_nm1=`fact $nm1`))
      8:       (( "result=n*fact_nm1" ));
      9:       echo $result
     10:    }

In addition to listing by line numbers, we can also list giving a
function name.  Below, instead of setting a breakpoint at line 5 and
running "'continue'" as we did above, we try something slightly shorter
and slightly different.  We give the line number on the "continue"
statement.  This is a little different in that a one-time break is made
on line 5.  Once that statement is reached the breakpoint is removed.

     bashdb<1> continue 5
     One-time breakpoint 1 set in file fact.sh, line 5.
     fact 0 is: 1
     (/tmp/fact.sh:5):
     5:	((nm1=n-1))
     bashdb<(2)> s
     6:	((fact_nm1=`fact $nm1`))
     bashdb<(3)> s
     2:	fact() {
     bashdb<(4)> T
     ->0 in file `fact.sh' at line 2
     ##1 fact("3") called from file `fact.sh' at line 12
     ##2 source("fact.sh") called from file `/usr/local/bin/bashdb' at line 154
     ##3 main("fact.sh") called from file `/usr/local/bin/bashdb' at line 0
     bashdb<(5)> c
     fact 3 is: 6
     Debugged program terminated normally. Use q to quit or R to restart.

When we stop at line 5 above, we have already run fact(0) and output the
correct results.  The output from the program "fact 0 is: 1" is
intermixed with the debugger output.  The 'T' command above requests
call stack output and this confirms that we are not in the fact(0) call
but in the fact(3) call.  There are 4 lines listed in the stack trace
even though there is just one call from the main program.  The top line
of the trace doesn't really represent a call, it's just where we
currently are in the program.  That last line is an artifact of invoking
bash from the bashdb script rather than running 'bash --debugger'.

   The last message in the output above 'Debugged program exited
normally.' is from the BASH debugger; it indicates script has finished
executing.  We can end our _bashdb_ session with the 'quit' command.

   Above we did our debugging session on the command line.  If you are a
GNU Emacs user, you can do your debugging inside that.  Also there is
a(nother) GUI interface called DDD that supports the BASH debugger.

   ---------- Footnotes ----------

   (1) Recall that variables in BASH don't need to be declared before
they are referred to and that the default value would be the a null
value which here prints as an empty string.


File: bashdb.info,  Node: Interactive Line Tracing Session,  Prev: Sample Session,  Up: Summary

1.2 Interactive Line Tracing Session
====================================

One of the things I had found disappointing about the default 'set -x'
tracing behavior is that no position information is given in the trace
output, in particular the line number and the file name.  However with
the introduction in Bash 3.0 of the introspection variables, also needed
to support the debugger, one can set '$PS4' to rectify this.  (I became
of this in a defunct blog
<http://raz.cx/blog/2005/08/handy-bash-debugging-trick.html>.)

   Here's what I use:
       PS4='(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]} - [${SHLVL},${BASH_SUBSHELL}, $?]
     '
   Note that the string is in single quotes, not double quotes and there
is a newline in the string.  By using single quotes, variables which
have a dollar in front of them in the string are expanded in the current
environment of the line that is about to be run rather than at the time
the variable 'PS4' is set.

   You might want to add this in your shell's start-up script, e.g.,
'.bashrc', or '.profile'.

   There is also facility inside the bash debugger showing position
information when tracing a script.  Here's a simple session.

     /usr/local/bin/bashdb /tmp/fact.sh
     Bourne-Again Shell Debugger, release bash-4.4-0.92
     Copyright 2002, 2003, 2004, 2006, 2007, 2008 Rocky Bernstein
     This is free software, covered by the GNU General Public License, and you are
     welcome to change it and/or distribute copies of it under certain conditions.

     (/tmp/fact.sh:11):
     11:	echo fact 0 is: `fact 0`
     bashdb<0> set linetrace on
     bashdb<1> cont
     (/tmp/fact.sh:11):
     level 1, subshell 1, depth 0:	echo fact 0 is: `fact 0`
     fact 0
     (/tmp/fact.sh:2):
     level 1, subshell 1, depth 1:	fact() {
     (/tmp/fact.sh:3):
     level 1, subshell 1, depth 1:	    local -i n=${1:0}
     (/tmp/fact.sh:4):
     level 1, subshell 1, depth 1:	    ((n==0)) && echo 1 && return
     (/tmp/fact.sh:4):
     level 1, subshell 1, depth 1:	    ((n==0)) && echo 1 && return
     echo 1
     (/tmp/fact.sh:4):
     level 1, subshell 1, depth 1:	    ((n==0)) && echo 1 && return
     return
     fact 0 is: 1
     (/tmp/fact.sh:13):
     level 1, subshell 0, depth 0:	echo fact 3 is: $(fact 3)
     (/tmp/fact.sh:13):
     level 1, subshell 1, depth 0:	echo fact 3 is: $(fact 3)
     fact 3
     (/tmp/fact.sh:2):
     level 1, subshell 1, depth 1:	fact() {
     (/tmp/fact.sh:3):
     level 1, subshell 1, depth 1:	    local -i n=${1:0}
     (/tmp/fact.sh:4):
     level 1, subshell 1, depth 1:	    ((n==0)) && echo 1 && return
     (/tmp/fact.sh:5):
     level 1, subshell 1, depth 1:	    ((nm1=n-1))
     (/tmp/fact.sh:6):
     level 1, subshell 1, depth 1:	    ((fact_nm1=`fact $nm1`))
     (/tmp/fact.sh:6):
     level 1, subshell 2, depth 1:	    ((fact_nm1=`fact $nm1`))
     fact $nm1
     (/tmp/fact.sh:2):
     level 1, subshell 2, depth 2:	fact() {
     ...
     level 1, subshell 4, depth 4:	fact() {
     (/tmp/fact.sh:3):
     level 1, subshell 4, depth 4:	    local -i n=${1:}
     (/tmp/fact.sh:4):
     level 1, subshell 4, depth 4:	    ((n==0)) && echo 1 && return
     (/tmp/fact.sh:4):
     level 1, subshell 4, depth 4:	    ((n==0)) && echo 1 && return
     echo 1
     (/tmp/fact.sh:4):
     level 1, subshell 4, depth 4:	    ((n==0)) && echo 1 && return
     return
     (/tmp/fact.sh:7):
     level 1, subshell 3, depth 3:	    ((result=n*fact_nm1))
     (/tmp/fact.sh:8):
     level 1, subshell 3, depth 3:	    echo $result
     (/tmp/fact.sh:7):
     level 1, subshell 2, depth 2:	    ((result=n*fact_nm1))
     (/tmp/fact.sh:8):
     level 1, subshell 2, depth 2:	    echo $result
     (/tmp/fact.sh:7):
     level 1, subshell 1, depth 1:	    ((result=n*fact_nm1))
     (/tmp/fact.sh:8):
     level 1, subshell 1, depth 1:	    echo $result
     fact 3 is: 6
     (/usr/local/bin/bashdb:260):
     level 1, subshell 0, depth -1:
     Debugged program terminated normally. Use q to quit or R to restart.
     bashdb<2>

   An explanation of the output.  The _level_ is how many invocations of
BASH are in effect before the statement shown is executed.  The
_subshell_ is how many subshells you are nested in.  Subshells are used
by command substitution--'`..'' and '$(...)'--as well as arithmetic
expressions '((...))'.  The _depth_ is the function depth or how many
calls you are nested in.  A "source" command also increases this depth.

   Notice also that in contrast to 'set -x' tracing, the line shown is
exactly as you entered it in the source.  So if you indented statements
in a meaningful way, it will help you understand the statement nesting
level.  But as before, if a line contains multiple statements, you are
_not_ executing the first statement in the line and 'set showcommand' is
not turned off (by default it is on), that statement is shown in
addition below the multi-statement line.  Such an example can be seen
right at the beginning where 'fact 0' is shown.

   If what you want to do is trace the _entire_ script as was done above
(and not stop in the debugger when the script is over), you can get the
same effect by using the '-X' or '--trace' option on the _bashdb_
command:

     /usr/local/bin/bashdb -X /tmp/fact.sh
     Bourne-Again Shell Debugger, release bash-4.4-0.92
     Copyright 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2011 Rocky Bernstein
     This is free software, covered by the GNU General Public License, and you are
     welcome to change it and/or distribute copies of it under certain conditions.

     (/usr/local/bin/bashdb:272):
     level 1, subshell 0, depth -1:	  . $_source_file
     (/tmp/fact.sh:11):
     level 1, subshell 0, depth 0:	echo fact 0 is: `fact 0`
     (/tmp/fact.sh:11):
     level 1, subshell 1, depth 0:	echo fact 0 is: `fact 0`
     fact 0
     (/tmp/fact.sh:2):
     level 1, subshell 1, depth 1:	fact() {
     (/tmp/fact.sh:3):
     level 1, subshell 1, depth 1:	    local -i n=${1:0}
     ...
     level 1, subshell 2, depth 2:	    echo $result
     (/tmp/fact.sh:7):
     level 1, subshell 1, depth 1:	    ((result=n*fact_nm1))
     (/tmp/fact.sh:8):
     level 1, subshell 1, depth 1:	    echo $result
     fact 3 is: 6
     (/usr/local/bin/bashdb:285):
     level 1, subshell 0, depth -1:

   If you issue a break (e.g. send a 'SIGINT' signal) while the program
is running you will go into the debugger (assuming your program doesn't
trap 'SIGINT').


File: bashdb.info,  Node: Invocation,  Next: Running,  Prev: Summary,  Up: Top

2 Getting in and out
********************

This chapter discusses how to start the BASH debugger, and how to get
out of it.  The essentials are:
   * type 'bash --debugger _script-name_' or 'bashdb _script-name_' to
     start the BASH debugger.  Or...
   * type 'bashdb -c _command string_' to give a string to run under the
     debugger.  Or ..
   * modify your program to enter the debugger at a particular point:
     'source ../bashdb-trace' and '_Dbg_debugger'.
   * type 'quit' or 'C-d' inside the debugger to exit.

   There are also two front-ends available as well.  An emacs front-end
which has _bashdb_ support among others is
<https://github.com/rocky/emacs-dbgr/wiki>.

* Menu:

* Starting the BASH debugger::    How to enter the BASH debugger
* Quitting the BASH debugger::    How to leave the BASH debugger
* Calling from Program::          Calling the debugger from inside your program


File: bashdb.info,  Node: Starting the BASH debugger,  Next: Quitting the BASH debugger,  Up: Invocation

2.1 Starting the BASH debugger
==============================

_Note: it is important to use a debugger-enabled bash.  You will get an
error message if the debugger is run under a version of BASH that does
not have debugging support._

   As mentioned above, one can enter the BASH debugger via Emacs or DDD.
However you don't have to use either of these.  And these still need a
way on their own to get things started.

   There are in fact two _other_ ways to start the BASH debugger.  The
first way is to pass the '--debugger' option to bash with the name of
your script the scripts arguments following that, or with a command
string ('-c').

     bash --debugger SCRIPT SCRIPT-ARGUMENTS...
     bash --debugger -c COMMAND-STRING...

   This calls a debugger initialization script.  It works much like a
BASH login profile which may set variables and define functions.  But
this shell profile is customized for debugging and as such arranges for
itself to get called before each statement is executed.  Although there
are some problems at present in I/O redirection that the method
described next doesn't have, it is expected that over time more features
will be enabled in bash when the '--debugger' option is in effect.

   The form 'bash --debugger -c ...' can be used to get into the
debugger without having to give a script name to debug.  Sometimes you
may want to do this just to see how the debugger works: try some
debugger commands or maybe get online help.  If you run 'ddd --bash'
without giving a script name, it in fact uses this form.

   In order for the '--debugger' option to work however, you must have
the debugger scripts installed in a place where the BASH debugger can
find them.  For this reason, in developing the BASH debugger, I use a
second method more often; it doesn't require the bash debugger to be
installed.  This method uses another script called _bashdb_ which allows
for giving its own options, the final option is signaled by adding
'--').  After this, the name of the script to debugged and any the
arguments to pass to that script are given.  Using this method, one
would start the debugger like this:

     bash PATH-TO-BASHDB/bashdb BASHDB-OPTIONS -- SCRIPT SCRIPT-ARGUMENTS...

   If you don't need to pass dash options to your program which might
get confused with the debugger options, then you don't need to add the
'--'.(1)

   As with the first method, 'bash' should be a debugger-enabled bash.
If _bashdb_ has the path to bash in it at the top (e.g. via '#!'), and
_bashdb_ can be found in your program-search path, then this might be
equivalent to the above:

     bashdb BASHDB-OPTIONS -- SCRIPT SCRIPT-ARGUMENTS...

   There are two or three disadvantages however of running a debugger
this way.  First '$0' will have the value _bashdb_ rather than the
script you are trying to run.  For some scripts this may change the
behavior of the debugged script.  Second a traceback will contain
additional lines showing the "source"-ing of the debugged script from
_bashdb_.  And third, although this way works better than the first
method, over time this way may come into disuse.

   An option that you'll probably need to use if bashdb isn't installed
but run out of the source code directory is '-L' which specifies the
directory that contains the debugger script files.

   You can further control how bashdb starts up by using command-line
options.  bashdb itself can remind you of the options available.

Type

     bashdb -h

to display all available options and briefly describe their use.

   When the bash debugger is invoked either by the _bashdb_ front-end
script or 'bash --debugging', the first argument that does not have an
associated option flag for _bashdb_ or 'bash' (as the case may be) is
used as the name a the script file to be debugged, and any following
options get passed the debugged script.

   Options for the _bashdb_ front-end are shown in the following list.

* Menu:

* Options for the bashdb script::   Options you can pass in starting bashdb

   ---------- Footnotes ----------

   (1) And in the interest of full disclosure, although this was not
shown in the example it is possible to add the '--' _after_ the script
name to be debugged but before the first program option with a dash.


File: bashdb.info,  Node: Options for the bashdb script,  Up: Starting the BASH debugger

2.1.1 Command-line options for _bashdb_ script
----------------------------------------------

You can run the BASH debugger in various alternative modes--for example,
in batch mode or quiet mode.

'-h | --help'
     This option causes the BASH debugger to print some basic help and
     exit.

'-V | --version'
     This option causes the BASH debugger to print its version number,
     no-warranty blurb, and exit.

'-A | --annodate LEVEL'
     Add additional output which allows front-ends to track what's going
     on without having to poll for such vital information.  The default
     annotation level is 0 (none).  If you are running inside GNU Emacs
     using the Emacs code from this package, an annotation level 3 when
     set will allow for automatic tracking of frames and breakpoints.
     *Note Annotate::.

'-c | --command CMD'
     Run the string instead of running a script

'-B | --basename'
     This option causes the BASH debugger to print its version number
     and no-warranty blurb, and exit.

'-n | --nx | --no-init'
     Do not execute commands found in any initialization files.
     Normally, BASH executes the commands in these files after all the
     command options and arguments have been processed.  *Note Command
     files: Command Files.

'-q | --quiet'
     "Quiet".  Do not print the introductory and copyright messages.
     These messages are also suppressed in batch mode.

'-t | --terminal | --tty TTY'
     Debugger output usually goes to a terminal rather than 'STDOUT'
     which the debugged program may use.  Determination of the tty or
     pseudo-tty is normally done automatically.  However if you want to
     control where the debugger output goes, use this option.

     If you want output to go to C<STDOUT>, use C<&1>.  Note: the C<&>
     may have to be escaped or quoted to avoid shell interpretation with
     forking.

'-x | --eval-command'
     execute debugger commands from CMDFILE.
'-L | --library DIRECTORY'

     Set directory where debugger files reside to DIRECTORY.  The
     default location is '../lib/bashdb' relative to the place that the
     bashdb script is located.  For example if bashdb is located in
     '/usr/share/bin/bashdb', the default library location will be
     '/usr/share/lib/bashdb' which may or may not exist.  If it doesn't
     you'll get an error when you run bashdb.  Only if the default
     location is incorrect, should you need to use the '-L' option.

'-T | --tempdir DIRECTORY'
     Set directory to use for writing temporary files.


File: bashdb.info,  Node: Quitting the BASH debugger,  Next: Calling from Program,  Prev: Starting the BASH debugger,  Up: Invocation

2.2 Quitting the BASH debugger
==============================

An interrupt (often 'C-c') does not exit from the BASH debugger, but
rather terminates the action of any the BASH debugger command that is in
progress and returns to the BASH debugger command level.  Inside a
debugger command interpreter, use 'quit' command (*note Quitting the
BASH debugger: Quit.).

   There way to terminate the debugger is to use the 'kill' command.
This does more forceful 'kill -9'.  It can be used in cases where 'quit'
doesn't work.


File: bashdb.info,  Node: Calling from Program,  Prev: Quitting the BASH debugger,  Up: Invocation

2.3 Calling the BASH debugger from inside your program
======================================================

Running a program from the debugger adds a bit of overhead and slows
down your program quite a bit.  Addressing this better would mean some
serious changes to BASH internals, and judging from experience in other
languages there still the slowdown is still noticeable.  If you have a
'configure' script generated by autoconf, and you want to stop in the
middle of the script, it can take quite a while.

   Furthermore, by necessity, debuggers change the operation of the
program they are debugging.  And this can lead to unexpected and
unwanted differences.  It has happened so often that the term
"Heisenbugs" (see <http://en.wikipedia.org/wiki/Heisenbug>) was coined
to describe the situation where the addition of the use of a debugger
(among other possibilities) changes behavior of the program so that the
bug doesn't manifest itself anymore.

   There is another way to get into the debugger aside from calling
_bashdb_ from the outset, and this adds no overhead or slowdown until
you reach the point at which you want to start debugging.  However for
this method you must change the script.  Because the debugger isn't
involved before the first call, there is no overhead; the script will
run at the same speed as if there were no debugger up to the point where
it is first invoked.
* Menu:

* Debugging a Running Shell Script::
* Program-Controlled Line Tracing::


File: bashdb.info,  Node: Debugging a Running Shell Script,  Next: Program-Controlled Line Tracing,  Up: Calling from Program

2.3.1 Debugging a Running Shell Script
--------------------------------------

In this section we'll show how to modify your script so that it enters
the debugger when you send it a signal, and then we will show how you
can call the debugger directly.

   In either case, you'll need to modify the script to load some the
debugger code.  The name of file to load is 'bashdb-trace' and it is
located in the directory where the other bash debugger files live.  For
example on GNU/Linux if it is in directory '/usr/local/share/bashdb',
you would first add to a BASH script the line:

         source /usr/local/share/bashdb/bashdb-trace

   Although I said that running under the debugger adds overhead which
slows down you program, the above command in of itself will _not_ cause
any slowdown.  If possible, it's best to put this somewhere in the
main-line code rather than in a function or in a subshell.  If it is put
in a function of subshell and you step outside of that, some of the
global variables set up in 'bashdb-trace' may be lost.  One the other
hand if you know your debugging will be confined to just the scope of
the 'source' command there is no problem.

   Here's a complete example.  In file 'debugit.sh'
     # This is my extra debug hook
       source _/usr/share/bashdb/bashdb-trace_ # adjust location

       echo $$
       while : ; do
             date=$(date)
             echo "$date"
             sleep 2
       done
   Now run:
       $ bash ./debugit.sh
       Bourne-Again Shell Debugger, release bash-3.1-0.08
       Copyright 2002, 2003, 2004, 2006 Rocky Bernstein
       This is free software, covered by the GNU General Public License, and you are
       welcome to change it and/or distribute copies of it under certain conditions.

       9435
       Thu Jun 19 02:43:06 EDT 2008
       Thu Jun 19 02:43:08 EDT 2008

   Sent it an "interrupt" signal
       kill -INT 9435

   And back to the running program:

       Program received signal SIGINT (2)...
       ->0 in file `./debugit.sh' at line 251  # not sure where 251 came from!
       ##1 main() called from file `./debugit.sh' at line 0
       bashdb<0> where
       ->0 in file `./debugit.sh' at line 9    # but this line number is now right
       ##1 main() called from file `./debugit.sh' at line 0
       bashdb<1> list 1
         1:   # Set up some interrupt handlers to go into the debugger
         2:   source /usr/share/bashdb/bashdb-trace
         3:
         4:   echo $$
         5:   while : ; do
         6:   date=$(date)
         7:   echo "$date"
         8:   sleep 2
         9:==>done
       bashdb<2> step
       (./debugit.sh:5):
       5:      while : ; do
       bashdb<3> step
       (./debugit.sh:6):
       6:      date=$(date)
       bashdb<4> continue -
   The command 'continue -' not only continues execution but it removes
the debug trap allowing the program to run at full speed.  It is
suitable only if there are no breakpoints that you care to stop at.

   By default, 'bashdb-trace' sets up a handler for the 'INT' exception.
If you down't want this or you want enter the debugger on a different
signal to be use, '_Dbg_handler'.  With this function you can specify
whether to show a call stack, stop (enter the debugger) and/or print an
indication that the a signal was seen.

   Here are some examples:
         _Dbg_handler INT print showstack nostop  # this is the default
         _Dbg_handler INT                         # same thing
         _Dbg_hander                              # same thing
         _Dbg_handler HUP print stop              # stop in debugger when getting

2.3.1.1 Explicit Debugging Calls.
.................................

As we saw in the last section 'bashdb-trace' installs some signal
handlers.  However you can make an explicit call to the debugger
          _Dbg_debugger

   Let's show an example of that.  We'll even do it under a condition:
       for ((i=1; i<=10; i++)) ;
             (( 5 == i )) && { _Dbg_debugger }
             date=$(date)
             echo "$date"
             sleep 2
       done

   The debugger will be called on the 5th iteration of this loop, when
'i' has the value 5.

   You can also supply the number of statements to skip and the options
to '_Dbg_debugger' just as you would to the debugger itself.  All of the
options listed in *note Options for the bashdb script:: can be used with
the exception of '-c' (run a command) and of course you don't supply the
name of a BASH script.

   For example to stop at the next line and suppress the banner you
could use '_Dbg_debugger 1 -q' in the above example.


File: bashdb.info,  Node: Program-Controlled Line Tracing,  Prev: Debugging a Running Shell Script,  Up: Calling from Program

2.3.2 Program-Controlled Line Tracing
-------------------------------------

You can also turn on and off line tracing.  Here's an example

       source _path-to-program_/bashdb-trace # modify location
        ...
       _Dbg_linetrace_on
       for i in `seq 10` ; do
          echo $i
       done
       _Dbg_linetrace_off
        _Dbg_QUIT_ON_QUIT=1

   The '_Dbg_QUIT_ON_QUIT' variable make sure the program doesn't stay
inside the debugger after it quits.  It can also be set earlier in the
program.

   Again '<path-to-program>' is whatever path needed to located
'<bashdb-trace>'.  For example it might be '</usr/local/share>' on some
GNU/Linux installations.


File: bashdb.info,  Node: Running,  Next: Debugger Command Reference,  Prev: Invocation,  Up: Top

3 Script Setup inside the BASH Debugger
***************************************

* Menu:

* Starting::                    Starting your script
* Command Files::               Command files
* Arguments::                   Your script's arguments
* Input/Output::                Your script's input and output
* Script/Debugger Interaction::   Keeping out of each other's harm


File: bashdb.info,  Node: Starting,  Next: Command Files,  Up: Running

3.1 Starting your script
========================

After invoking the debugger you should be on the first stoppable line of
your program to be debugged.  At this point you can issue debugger
commands to set breakpoints (*note Setting breakpoints: Set Breaks.), or
watchpoints (*note Setting watchpoints: Set Watchpoints.), or start
continue the execution of the program (*note Resuming Execution:
Resuming Execution.).

'restart [ARGS]'
'run [ARGS]'
'R [ARGS]'
     Use the 'restart' command to restart your script under the BASH
     debugger.  Without any arguments, the script name and parameters
     from the last invocation are used.  The BASH debugger tries to
     maintain the settings, watchpoints, breakpoints, actions and so on.
     Internally it uses line numbers and filenames to record he position
     of interesting places in your program; so if your program changes
     some or all of these numbers may be off.  Environment variable
     'DBG_RESTART_FILE' is and a temporary file are used to signal a
     restart, so you shouldn't uset 'DBG_RESTART_FILE' (or any
     environment variable starting with 'BASHDB_'.


File: bashdb.info,  Node: Command Files,  Next: Arguments,  Prev: Starting,  Up: Running

3.2 Command files
=================

A command file for the BASH debugger is a file of lines that are the
BASH debugger commands.  Comments (lines starting with '#') may also be
included.  An empty line in a command file does nothing; it does not
mean to repeat the last command, as it would from the terminal.

   When you start the BASH debugger, it automatically executes commands
from its "init files", normally called '.bashdbinit'(1).  During
startup, the BASH debugger does the following:

  1. Reads the init file (if any) in your home directory(2).

  2. Processes command line options and operands.

  3. Reads the init file (if any) in the current working directory.

  4. Reads command files specified by the '-x' option.

   The init file in your home directory can set options (such as 'set
complaints') that affect subsequent processing of command line options
and operands.  Init files are not executed if you use the '-x' option
(*note bashdb script options: Options for the bashdb script.).

   On some configurations of the BASH debugger, the init file is known
by a different name (these are typically environments where a
specialized form of the BASH debugger may need to coexist with other
forms, hence a different name for the specialized version's init file).
These are the environments with special init file names:

   You can also request the execution of a command file with the
'source' command:

'source FILENAME'
     Execute the command file FILENAME.

   The lines in a command file are executed sequentially.  They are not
printed as they are executed.  If there is an error, execution proceeds
to the next command in the file.

   ---------- Footnotes ----------

   (1) The DJGPP port of the BASH debugger uses the name 'bashdb.ini'
instead, due to the limitations of file names imposed by DOS
filesystems.

   (2) On DOS/Windows systems, the home directory is the one pointed to
by the 'HOME' environment variable.


File: bashdb.info,  Node: Arguments,  Next: Input/Output,  Prev: Command Files,  Up: Running

3.3 Your script's arguments
===========================

The arguments to your script can be specified by the arguments of the
'restart' command.  They are passed to a shell, which expands wild-card
characters and performs redirection of I/O, and thence to your script.

   'restart' with no arguments uses the same arguments used by the
previous 'restart', or those set by the 'set args' command..

'set args'
     Specify the arguments to be used if your program is rerun.  If 'set
     args' has no arguments, 'restart' executes your program with no
     arguments.  Once you have run your program with arguments, using
     'set args' before the next 'restart' is the only way to run it
     again without arguments.

'show args'
     Show the arguments to give your program when it is started.


File: bashdb.info,  Node: Input/Output,  Next: Script/Debugger Interaction,  Prev: Arguments,  Up: Running

3.4 Your script's input and output
==================================

By default, the script you run under the BASH debugger does input and
output to the same terminal that BASH uses.  Before running the script
to be debugged, the debugger records the tty that was in effect.  All of
its output is then written to that.  However you can change this when
using the 'bashdb' script using the '-t' option.

'info terminal'
     Displays information recorded by the BASH debugger about the
     terminal modes your program is using.

   Another way to specify where your script should do input and output
is with the 'tty' command.  This command accepts a file name as
argument, and causes this file to be the default for future 'restart'
commands.  It also resets the controlling terminal for the child
process, for future 'restart' commands.  For example,

     tty /dev/ttyb

directs that processes started with subsequent 'restart' commands
default to do input and output on the terminal '/dev/ttyb' and have that
as their controlling terminal.

   An explicit redirection in 'restart' overrides the 'tty' command's
effect on the input/output device, but not its effect on the controlling
terminal.

   When you use the 'tty' command or redirect input in the 'restart'
command, only the input _for your script_ is affected.  The input for
the BASH debugger still comes from your terminal.


File: bashdb.info,  Node: Script/Debugger Interaction,  Prev: Input/Output,  Up: Running

3.5 Script/Debugger Interaction
===============================

The BASH debugger and your program live in the same variable space so to
speak.  BASH does not have a notion of module scoping or lexical hiding
(yet) as is found in modern programming languages and in modern versions
of the Korn shell.  This then imposes some additional care and
awareness.

   Most of the variables and functions used inside the BASH debugger
start '_Dbg_', so please don't use variables or functions with these
names in your program.

   _Note: there are some other variables that begin with just an
underscore ('_'); over time these will be phased out.  But until then,
avoid those or consult what is used by the debugger.  Run 'bashdb
--debugger -c "declare -p"' to list all the variables in use including
those used by the debugger._

   A number of environment variables are also reserved for use; these
start with 'DBG_'.  For example: 'DBG_INPUT', 'DBG_LEVEL' and,
'_Dbg_QUIT_ON_QUIT' (*note Debug: Debug.), 'DBG_RESTART_FILE' (*note
Starting: Starting.), to name a few.  Finally, there are some BASH
environment dynamic variables and these start with 'BASH_'.  For example
'BASH_SUBSHELL' (*note Debug: Debug.), 'BASH_COMMAND' (*note Command
Display: Command Display.), 'BASH_LINENO', and 'BASH_SOURCE' to name a
few.

   Inside the debugger some variables may be redefined.  In particular
'IFS' and 'PS4', and various dollar variables '$?', '$1', '$2', etc.
The values before entering the debugger are saved and those variables
have their old values restored when leaving the debugger.  However you
may notice these difference in various debugger commands.  For example
'examine PS4' might not return the same value as 'eval declare -p PS4'.
The former is picking the debugger value while the 'eval' is careful to
restore the value to what it was before entering the debugger.

   In order to do its work The BASH debugger sets up a 'DEBUG' trap.
Consequently a script shouldn't reset this or the debugger will lose
control.  The BASH debugger also sets up an 'EXIT' handler so that it
can gain control after the script finishes.  Another signal intercepted
is the an interrupt or 'INT' signal.  For more information about signal
handling, *note Signals: Signals.


File: bashdb.info,  Node: Debugger Command Reference,  Next: BASH Debugger Bugs,  Prev: Running,  Up: Top

4 BASH Debugger Command Reference
*********************************

You can abbreviate the long name of the BASH debugger command to the
first few letters of the command name, if that abbreviation is
unambiguous; and you can repeat the 'next' or 'step' commands by typing
just <RET>.  Some commands which require a parameter, such as 'print'
remember the argument that was given to them.

* Menu:

* Command Syntax::       How to give commands to the BASH debugger
* Help::                 How to ask for help (help)
* Quit::                 Leaving the debugger (quit, kill)
* Stopping::             Stopping and continuing (break, watch, step, cont...)
* Stack::                Examining the stack frame (where, up, down, frame)
* List::                 Printing source files (list)
* Edit::                 Editing source files (edit)
* Search::               Searching source files (/pat/ ?pat?)
* Data::                 Examining data (print, examine, info variables)
* Auto Display::         Executing expressions on stop (display, undisplay)
* Evaluation/Execution:: Arbitrary execution (eval, eval? shell)
* Interfacing to the OS:: Interfacing to the OS (cd, pwd)
* Information and Settings::  Status and Debugger settings (info, show)
* Controlling bashdb::   Controlling bashdb (annotate, file, prompt, history...)


File: bashdb.info,  Node: Command Syntax,  Next: Help,  Up: Debugger Command Reference

4.1 Command syntax
==================

A BASH debugger command is a single line of input.  There is no limit on
how long it can be.  It starts with a command name, which is followed by
arguments whose meaning depends on the command name.  For example, the
command 'step' accepts an argument which is the number of times to step,
as in 'step 5'.  You can also use the 'step' command with no arguments.
Some commands do not allow any arguments.

   A blank line as input to the BASH debugger (typing just <RET>) means
to repeat the previous next or step command.

   Any text from a '#' to the end of the line is a comment; it does
nothing.  This is useful mainly in command files (*note Command files:
Command Files.).


File: bashdb.info,  Node: Help,  Next: Quit,  Prev: Command Syntax,  Up: Debugger Command Reference

4.2 Getting help ('help')
=========================

Once inside the BASH debugger, you can always ask it for information on
its commands, using the command 'help'.

'help'
'h'
     You can use 'help' (abbreviated 'h') with no arguments to display a
     short list of named classes of commands:

     bashdb<0> help
     Available commands:
       action     condition  edit     frame    load     run     source  unalias
       alias      continue   enable   handle   next     search  step    undisplay
       backtrace  debug      eval     help     print    set     step-   untrace
       break      delete     examine  history  pwd      shell   step+   up
       clear      disable    export   info     quit     show    tbreak  watch
       commands   display    file     kill     return   signal  trace   watche
       complete   down       finish   list     reverse  skip    tty

     Readline command line editing (emacs/vi mode) is available.
     Type "help" followed by command name for full documentation.

'help COMMAND'
     With a command name as 'help' argument, the BASH debugger displays
     short information on how to use that command.

          bashdb<0> help list
          list [START|.|FN] [COUNT] -- List lines of a script.

          START is the starting line or dot (.) for current line. Subsequent
          list commands continue from the last line listed. If a function name
          is given list the text of the function.

          If COUNT is omitted, use the setting LISTSIZE. Use "set listsize" to
          change this setting.

          Aliases for list: l

     In addition to 'help', you can use the debugger command 'info' to
     inquire about the state of your script, or the state of the BASH
     debugger itself.  The listings under 'info' in the Index point to
     all the sub-commands.  *Note Command Index::.

'info'
     This command (abbreviated 'i') is for describing the state of your
     program.  For example, you can list the arguments given to your
     script with 'info args', or list the breakpoints you have set with
     'info breakpoints'.  You can get a complete list of the 'info'
     sub-commands with 'help info'.

          bashdb<0> help info
          List of info subcommands:

          info args -- Argument variables (e.g. $1, $2, ...) of the current stack frame.
          info breakpoints -- Status of user-settable breakpoints
          info display -- Show all display expressions
          info files -- Source files in the program
          info functions -- All function names
          info line -- list current line number and and file name
          info program -- Execution status of the program.
          info signals -- What debugger does when program gets various signals
          info source -- Information about the current source file
          info stack -- Backtrace of the stack
          info terminal -- Print terminal device
          info variables -- All global and static variable names
          info warranty -- Various kinds of warranty you do not have

          Aliases for info: i
          bashdb<1> info source
          Current script file is parm.sh
          Located in /tmp/parm.sh
          Contains 34 lines.


File: bashdb.info,  Node: Quit,  Next: Stopping,  Prev: Help,  Up: Debugger Command Reference

4.3 Quitting the BASH debugger ('quit', 'kill')
===============================================

'quit [EXPRESSION]'
'quit [EXPRESSION [SUBSHELL-LEVELS]]'
'q'

     To exit the BASH debugger, use the 'quit' command (abbreviated
     'q'), or type an end-of-file character (usually 'C-d').  If you do
     not supply EXPRESSION, the BASH debugger will try to terminate
     normally or with exit code 0.  Otherwise it will terminate using
     the result of EXPRESSION as the exit code.

     A simple 'quit' tries to terminate all nested subshells that may be
     in effect.  If you are nested a subshell, this is normally
     indicated in a debugger prompt by the number of parentheses that
     the history number is inside -- no parenthesis means there is no
     subshell in effect.  The dynamic variable 'BASH_SUBSHELL' also
     contains the number of subshells in effect.

     If you want only to terminate some number of subshells but not all
     of them, you can give a count of the number of subshells to leave
     after the return-code expression.  To leave just one level of
     subshell 'return' does almost the same thing.  (See *note
     Returning: Returning.) There is a subtle difference between the two
     though: 'return' will leave you at the beginning of the next
     statement while 'quit' may leave you at the place the subshell was
     invoked which may be in the middle of another command such as an
     assignment statement or condition test.

     If the environment variable '_Dbg_QUIT_ON_QUIT' is set, when the
     program terminates, the debugger will also terminate too.  This may
     be useful if you are debugging a script which calls another script
     and you want this inner script just to return to the outer script.

'kill'
'k'
     In situations where 'quit' doesn't work we provide an alternative
     and more forceful quit command: 'kill'.  This sends to the OS
     non-maskable KILL signal with the debugger process number.  No
     cleanup of temporary files is done by the program.


File: bashdb.info,  Node: Stopping,  Next: Stack,  Prev: Quit,  Up: Debugger Command Reference

4.4 Stopping and Resuming Execution
===================================

One important use of a debugger is to stop your program _before_ it
terminates so that if your script might run into trouble, you can
investigate and find out why.  However should your script accidentally
continue to termination, the BASH debugger has arranged for it not to
leave the debugger without your explicit instruction.  That way, you can
restart the program using the same command arguments.

   Inside the BASH debugger, your script may stop for any of several
reasons, such as a signal, a breakpoint, or reaching a new line after a
debugger command such as 'step'.  You may then examine and change
variables, set new breakpoints or remove old ones, and then continue
execution.

* Menu:

* Breakpoints::          Breakpoints, watchpoints (break, tbreak, watch, watche, clear)
* Resuming Execution::   Resuming execution (continue, step, next, skip, finish, return, debug)
* Signals::              Signals


File: bashdb.info,  Node: Breakpoints,  Next: Resuming Execution,  Up: Stopping

4.4.1 Breakpoints, watchpoints ('break', 'tbreak', 'watch', 'watche'...)
------------------------------------------------------------------------

A "breakpoint" makes your script stop whenever a certain point in the
program is reached.  For each breakpoint, you can add conditions to
control in finer detail whether your script stops.

   You specify the place where your script should stop with the 'break'
command and its variants (*note Setting breakpoints: Set Breaks.).
These commands allow own to specify the location by line number and file
name or function name.

   A "watchpoint" is a special breakpoint that stops your script when
the value of an expression changes.  There is a different command to set
watchpoints (*note Setting watchpoints: Set Watchpoints.).

   But aside from that, you can manage a watchpoint like any other
breakpoint: you delete enable, and disable both breakpoints and
watchpoints using the same commands.

   You can arrange to have values from your program displayed
automatically whenever BASH stops at a breakpoint.  *Note Automatic
display: Auto Display.

   The BASH debugger assigns a number to each breakpoint when you create
it; these numbers are successive integers starting with one.  In many of
the commands for controlling various features of breakpoints you use the
breakpoint number to say which breakpoint you want to change.  Each
breakpoint may be "enabled" or "disabled"; if disabled, it has no effect
on your script until you enable it again.

   Watchpoint numbers however are distinguished from breakpoint numbers
by virtue of their being suffixed with the either an upper- or
lower-case 'W'. For example, to enable breakpoint entry 0 along with
watchpoint entry 1 you would write 'enable 1 2w', the "2w" refers to the
watchpoint; "2W" would work just as well.

* Menu:

* Set Breaks::                      Setting breakpoints (break, tbreak)
* Set Watchpoints::                 Setting watchpoints (watch, watche)
* Break Commands::                  Breakpoint command lists (command)
* Delete Breaks::                   Deleting breakpoints (delete, clear)
* Disabling::                       Disabling breakpoints (disable, enable)
* Conditions::                      Break conditions (condition)


File: bashdb.info,  Node: Set Breaks,  Next: Set Watchpoints,  Up: Breakpoints

4.4.1.1 Setting breakpoints ('break' 'tbreak')
..............................................

Breakpoints are set with the 'break' command (abbreviated 'b').

'break FUNCTION'
     Set a breakpoint at entry to function FUNCTION.

'break LINENUM'
     Set a breakpoint at line LINENUM in the current source file.  The
     current source file is the last file whose source text was printed.
     The breakpoint will stop your script just before it executes any of
     the code on that line.

'break FILENAME:LINENUM'
     Set a breakpoint at line LINENUM in source file FILENAME; FILENAME
     has to be one of the files previously read in and has to be
     specified exactly as the name used when read in.  For a list of
     read-in files, use the 'info files' command.

'break ... if COND'
     Set a breakpoint with condition COND; evaluate the expression COND
     each time the breakpoint is reached, and stop only if the value is
     nonzero--that is, if COND evaluates as true.  The expression is
     evaluated via the 'let' built-in function.  '...' stands for one of
     the possible arguments described above (or no argument) specifying
     where to break.  The word "if" is often optional and is necessary
     only '...' is omitted.  *Note Break conditions: Conditions, for
     more information on breakpoint conditions.

     Examples:
          bashdb<0> break fn1
          Breakpoint 1 set in file parm.sh, line 3.
          bashdb<1> break 28
          Breakpoint 2 set in file parm.sh, line 28.
          bashdb<2> break parm.sh:29
          Breakpoint 3 set in file parm.sh, line 29.
          bashdb<3> break 28 if x==5
          Breakpoint 4 set in file parm.sh, line 28.

'tbreak ARGS'
     Set a breakpoint enabled only for one stop.  ARGS are the same as
     for the 'break' command, and the breakpoint is set in the same way,
     but the breakpoint is automatically deleted after the first time
     your program stops there.  *Note Disabling breakpoints: Disabling.

'info breakpoints [N]'
'info break [N]'
'info watchpoints [N]'
     Print a table of all breakpoints, watchpoints set and not deleted,
     with the following columns for each breakpoint:

     _Breakpoint Numbers ('Num')_
     _Enabled or Disabled ('Enb')_
          Enabled breakpoints are marked with '1'.  '0' marks
          breakpoints that are disabled (not enabled).
     _Count_
          The number of times that breakpoint or watchpoint has been
          hit.
     _File and Line ('file:line')_
          The filename and line number inside that file where of
          breakpoint in the script.  The file and line are separated
          with a colon.
     _Condition_
          A condition (an arithmetic expression) which when true causes
          the breakpoint to take effect.

     If a breakpoint is conditional, 'info break' shows the condition on
     the line following the affected breakpoint; breakpoint commands, if
     any, are listed after that.

     'info break' displays a count of the number of times the breakpoint
     has been hit.

     'info break' with a breakpoint number N as argument lists only that
     breakpoint.

     Examples:
          bashdb<4> info break
          Breakpoints at following places:
          Num Type       Disp Enb What
          1   breakpoint keep y   parm.sh:3
          2   breakpoint keep y   parm.sh:28
          3   breakpoint keep y   parm.sh:29
          4   breakpoint keep y   parm.sh:28
          No watch expressions have been set.
          bashdb<5> info break 4
          Num Type       Disp Enb What
          4   breakpoint keep y   parm.sh:28
          No watch expressions have been set.

   the BASH debugger allows you to set any number of breakpoints at the
same place in your script.  There is nothing silly or meaningless about
this.  When the breakpoints are conditional, this is even useful (*note
Break conditions: Conditions.).


File: bashdb.info,  Node: Set Watchpoints,  Next: Break Commands,  Prev: Set Breaks,  Up: Breakpoints

4.4.1.2 Setting watchpoints ('watch', 'watche')
...............................................

You can use a watchpoint to stop execution whenever the value of an
expression changes, without having to predict a particular place where
this may happen.  As with the 'print' (*note Examining Data: Data.), the
idiosyncrasies of a BASH or any POSIX shell derivative suggest using two
commands.  The 'watch' command is just for a single variables; the
'watche' command uses the builtin "let" command to evaluate an
expression.  If the variable you are tracking can take a string value,
issuing something like 'watch foo' will not have the desired effect--any
string assignment to 'foo' will have a value 0 when it is assigned via
"let."

'watch VAR'
     Set a watchpoint for a variable.  the BASH debugger will break when
     the value of VAR changes.  In this command do not add a leading
     dollar symbol to VAR.

'watche EXPR'
     Set a watchpoint for an expression via the builtin "let" command.
     the BASH debugger will break when EXPR is written into by the
     program and its value changes.  Not that this may not work for
     tracking arbitrary string value changes.  For that use 'watch'
     described earlier.


File: bashdb.info,  Node: Break Commands,  Next: Delete Breaks,  Prev: Set Watchpoints,  Up: Breakpoints

4.4.1.3 Breakpoint command lists ('commands')
.............................................

'commands [BNUM]'
'... COMMAND-LIST ...'
'end'
     Specify a list of commands for breakpoint number BNUM.  The
     commands themselves appear on the following lines.  Type a line
     containing just 'end' to terminate the commands.

     To remove all commands from a breakpoint, type 'commands' and
     follow it immediately with 'end'; that is, give no commands.

     With no BNUM argument, 'commands' refers to the last breakpoint,
     watchpoint, or catchpoint set (not to the breakpoint most recently
     encountered).

   Pressing <RET> as a means of repeating the last debugger command is
disabled within a COMMAND-LIST.

   You can use breakpoint commands to start your program up again.
Simply use the 'continue' command, or 'step', or any other command that
resumes execution.

   Any other commands in the command list, after a command that resumes
execution, are ignored.  This is because any time you resume execution
(even with a simple 'next' or 'step'), you may encounter another
breakpoint--which could have its own command list, leading to
ambiguities about which list to execute.

   If the first command you specify in a command list is 'silent', the
usual message about stopping at a breakpoint is not printed.  This may
be desirable for breakpoints that are to print a specific message and
then continue.  If none of the remaining commands print anything, you
see no sign that the breakpoint was reached.  'silent' is meaningful
only at the beginning of a breakpoint command list.

   The commands 'echo', 'output', and 'printf' allow you to print
precisely controlled output, and are often useful in silent breakpoints.

   For example, here is how you could use breakpoint commands to print
the value of 'x' at entry to 'foo' whenever 'x' is positive.

     break foo if x>0
     commands
     silent
     printf "x is %d\n",x
     cont
     end

   One application for breakpoint commands is to compensate for one bug
so you can test for another.  Put a breakpoint just after the erroneous
line of code, give it a condition to detect the case in which something
erroneous has been done, and give it commands to assign correct values
to any variables that need them.  End with the 'continue' command so
that your program does not stop, and start with the 'silent' command so
that no output is produced.  Here is an example:

     break 403
     commands
     silent
     set x = y + 4
     cont
     end


File: bashdb.info,  Node: Delete Breaks,  Next: Disabling,  Prev: Break Commands,  Up: Breakpoints

4.4.1.4 Deleting breakpoints ('clear', 'delete')
................................................

It may desirable to eliminate a breakpoint or watchpoint once it has
done its job and you no longer want your script to stop there.  This is
called "deleting" the breakpoint.  A breakpoint that has been deleted no
longer exists; it is forgotten.

   With the 'clear' command you can delete breakpoints according to
where they are in your script.  With the 'delete' command you can delete
individual breakpoints, or watchpoints by specifying their breakpoint
numbers.  _Note: as described below under the "clear" command, "d" is an
alias for "clear", not "delete".  _

   It is not necessary to delete a breakpoint to proceed past it.  the
BASH debugger automatically ignores breakpoints on the first instruction
to be executed when you continue execution.

'clear'
     Delete any breakpoints at the next instruction to be executed in
     the selected stack frame (*note Selecting a frame: Selection.).
     When the innermost frame is selected, this is a good way to delete
     a breakpoint where your script just stopped.

     It may seem odd that we have an alias "d" for "clear."  It so
     happens that Perl's debugger use "d" for its delete command and the
     delete concept in Perl's debugger corresponds to "clear" in GDB.
     (Perl doesn't have a notion of breakpoint entry numbers).  So in
     order to be compatible with both debugger interfaces, "d" is used
     as an alias for "clear."  Clear?

'clear FUNCTION'
'clear FILENAME:FUNCTION'
     Delete any breakpoints set at entry to the function FUNCTION.

'clear LINENUM'
'd LINENUM'
     Delete any breakpoints set at or within the code of the specified
     line.

'delete [BREAKPOINTS]'
     Delete the breakpoints, watchpoints specified as arguments.

     If no argument is specified, delete all breakpoints (the BASH
     debugger asks confirmation, unless you have 'set confirm off').
     You can abbreviate this command as 'de'.

     Note that for compatibility with Perl's debugger, 'd' means
     something else: 'clear'.


File: bashdb.info,  Node: Disabling,  Next: Conditions,  Prev: Delete Breaks,  Up: Breakpoints

4.4.1.5 Disabling breakpoints ('disable', 'enable')
...................................................

Rather than deleting a breakpoint or watchpoint, you might prefer to
"disable" it.  This makes the breakpoint inoperative as if it had been
deleted, but remembers the information on the breakpoint so that you can
"enable" it again later.

   You disable and enable breakpoints, watchpoints, and catchpoints with
the 'enable' and 'disable' commands, optionally specifying one or more
breakpoint numbers as arguments.  Use 'info break' or 'info watch' to
print a list of breakpoints, watchpoints, and catchpoints if you do not
know which numbers to use.

   A breakpoint, watchpoint, or catchpoint can have any of four
different states of enablement:

   * Enabled.  The breakpoint stops your program.  A breakpoint set with
     the 'break' command starts out in this state.
   * Disabled.  The breakpoint has no effect on your program.
   * Enabled once.  The breakpoint stops your program, but then becomes
     disabled.
   * Enabled for deletion.  The breakpoint stops your program, but
     immediately after it does so it is deleted permanently.  A
     breakpoint set with the 'tbreak' command starts out in this state.

   You can use the following commands to enable or disable breakpoints,
watchpoints, and catchpoints:

'disable [BREAKPOINTS]'
     Disable the specified breakpoints--or all breakpoints, if none are
     listed.  A disabled breakpoint has no effect but is not forgotten.
     All options such as ignore-counts, conditions and commands are
     remembered in case the breakpoint is enabled again later.  You may
     abbreviate 'disable' as 'dis'.

'enable [BREAKPOINTS]'
     Enable the specified breakpoints (or all defined breakpoints).
     They become effective once again in stopping your program.

   Except for a breakpoint set with 'tbreak' (*note Setting breakpoints:
Set Breaks.), breakpoints that you set are initially enabled;
subsequently, they become disabled or enabled only when you use one of
the commands above.  (The command 'until' can set and delete a
breakpoint of its own, but it does not change the state of your other
breakpoints; see *note Resuming Execution: Resuming Execution.)


File: bashdb.info,  Node: Conditions,  Prev: Disabling,  Up: Breakpoints

4.4.1.6 Break conditions ('condition')
......................................

The simplest sort of breakpoint breaks every time your script reaches a
specified place.  You can also specify a "condition" for a breakpoint.
A condition is just a BASH expression.

   Break conditions can be specified when a breakpoint is set, by using
'if' in the arguments to the 'break' command.  *Note Setting
breakpoints: Set Breaks.  A breakpoint with a condition evaluates the
expression each time your script reaches it, and your script stops only
if the condition is _true_.  They can also be changed at any time with
the 'condition' command.

   There is also a notion of a "one-time" breakpoint which gets deleted
as soon as it is hit, so that that breakpoint is executed once only.

   Conditions are also accepted for watchpoints; you may not need them,
since a watchpoint is inspecting the value of an expression anyhow--but
it might be simpler, say, to just set a watchpoint on a variable name,
and specify a condition that tests whether the new value is an
interesting one.

'condition BNUM EXPRESSION'
     Specify EXPRESSION as the break condition for breakpoint BNUM.
     After you set a condition, breakpoint BNUM stops your program only
     if the value of EXPRESSION is true (nonzero).

'condition BNUM'
     Remove the condition from breakpoint number BNUM.  It becomes an
     ordinary unconditional breakpoint.

BASH does not actually evaluate EXPRESSION at the time the 'condition'
command (or a command that sets a breakpoint with a condition, like
'break if ...') is given, however.

   Examples;
     condition 1 x>5   # Stop on breakpoint 0 only if x>5 is true.
     condition 1       # Change that! Unconditinally stop on breakpoint 1.


File: bashdb.info,  Node: Resuming Execution,  Next: Signals,  Prev: Breakpoints,  Up: Stopping

4.4.2 Resuming Execution ('step', 'next', 'finish', 'skip', 'continue', 'debug', 'return')
------------------------------------------------------------------------------------------

A typical technique for using stepping is to set a breakpoint (*note
Breakpoints; watchpoints: Breakpoints.) at the beginning of the function
or the section of your script where a problem is believed to lie, run
your script until it stops at that breakpoint, and then step through the
suspect area, examining the variables that are interesting, until you
see the problem happen.

   "Continuing" means resuming program execution until your script
completes normally.  In contrast, "stepping" means executing just one
more "step" of your script, where "step" may mean either one line of
source code.  Either when continuing or when stepping, your script may
stop even sooner, due to a breakpoint or a signal.

* Menu:

* Step::          running the next statement (step)
* Next::          running the next statement skipping over functions (next)
* Finish::        running until the return of a function or "source" (finish)
* Skip::          skipping the next statement (skip)
* Continue::      continuing execution (continue)
* Debug::         debugging into another program (debug)
* Returning::     returning


File: bashdb.info,  Node: Step,  Next: Next,  Up: Resuming Execution

4.4.2.1 Step ('step')
.....................

'step[+|-] [COUNT]'
     Continue running your script until control reaches a different
     source line, then stop it and return control to the BASH debugger.
     An default alias alias for this is 's'.

     The 'step' command only stops at the first instruction of a source
     line.  This prevents the multiple stops that could otherwise occur
     in 'switch' statements, 'for' loops, etc.  'step' continues to stop
     if a function that has debugging information is called within the
     line.  In other words, 'step' _steps inside_ any functions called
     within the line.

     Sometimes you want to step ensure that the next line is different
     from the one you currently are on.  To do this, add the '+' suffix.
     And if you find you want to do this all of the time there is a
     setting 'force' that will have this be the default behavior.  On
     the other hand if you want to be explicit about not having this
     behavior even when 'force' is in effect add the '-' suffix.

     With a count, continue running as in 'step', but do so COUNT times.
     If a breakpoint is reached, or a signal not related to stepping
     occurs before COUNT steps, stepping stops right away.


File: bashdb.info,  Node: Next,  Next: Finish,  Prev: Step,  Up: Resuming Execution

4.4.2.2 Next ('next')
.....................

'next [COUNT]'
     Continue to the next source line in the current (innermost) stack
     frame.  This is similar to 'step', but function calls that appear
     within the line of code are executed without stopping.  Execution
     stops when control reaches a different line of code at the original
     stack level that was executing when you gave the 'next' command.
     This command is abbreviated 'n'.

     An argument COUNT is a repeat count, as for 'step'.


File: bashdb.info,  Node: Finish,  Next: Skip,  Prev: Next,  Up: Resuming Execution

4.4.2.3 Finish ('finish')
.........................

'finish'
     Continue running until just after function returns.  _Currently,
     the line shown on a return is the function header, unless the
     'return' builtin function is executed in which case it is the line
     number of the 'return' function._

     Contrast this with the 'return' command (*note Returning from a
     function: Returning.) and the 'quit' (*note Quitting the BASH
     debugger: Quitting the BASH debugger.).


File: bashdb.info,  Node: Skip,  Next: Continue,  Prev: Finish,  Up: Resuming Execution

4.4.2.4 Skip ('skip')
.....................

'skip [COUNT]'
     Skip execution of the next source line.  This may be useful if you
     have an action that "fixes" existing code in the script.  The
     'debug' command internally uses the 'skip' command to skip over
     existing non-debugged invocation that was presumably just run.


File: bashdb.info,  Node: Continue,  Next: Debug,  Prev: Skip,  Up: Resuming Execution

4.4.2.5 Continue ('continue')
.............................

'continue [- | LINE-SPECIFICATION]'
'c [LINE-SPECIFICATION]'
     Resume program execution, at the address where your script last
     stopped; any breakpoints set at that address are bypassed.

     The optional argument LINE-SPECIFICATION allows you to specify a
     location (a line number, function, or filename linenumber
     combination) to set a one-time breakpoint which is deleted when
     that breakpoint is reached.  Should the program stop before that
     breakpoint is reached, in a listing of the breakpoints you will see
     this entry with the condition 9999 which indicates a one-time
     breakpoint.

     If instead of a line specification you enter '-', debugging will be
     turned of after continuing causing the program to run at full
     speed.

   To resume execution at a different place, you can use 'return' (*note
Returning from a function: Returning.) to go back to the calling
function or sourced script.  If you are nested inside a subshell, 'quit'
with a value for the number of subshells to exit also functions like a
return.


File: bashdb.info,  Node: Debug,  Next: Returning,  Prev: Continue,  Up: Resuming Execution

4.4.2.6 Debug ('debug')
.......................

'debug [SCRIPT-NAME]'
     Debug into SCRIPT-NAME.  If no name is given the current source
     line is used.  In either case the options are prepended to cause
     the debugger to run.

     The nesting level of the debugger is saved inside environment
     variable '_Dbg_DEBUGGER_LEVEL'.  The debugger prompt indicates the
     level of nesting by enclosing the history in that many nestings of
     '<>' symbols.


File: bashdb.info,  Node: Returning,  Prev: Debug,  Up: Resuming Execution

4.4.2.7 Returning from a function, sourced file, or subshell ('return')
.......................................................................

'return'
     You can cancel execution of a function call or a subshell with the
     'return' command.

   The 'return' command does not resume execution; it leaves the program
stopped in the state that would exist if the function had just returned.
See also the 'quit' command (*note Quitting the BASH debugger: Quit.).
In some situations 'return' is similar to 'quit': in particular when the
script is _not_ currently inside in a function and the number of
subshells in effect is 0, or when a subshell count of 1 is given on the
'quit' command.

   In contrast, the 'finish' command (*note Finish: Finish.) resumes
execution until the selected stack frame returns naturally.


File: bashdb.info,  Node: Signals,  Prev: Resuming Execution,  Up: Stopping

4.4.3 Signals ('handle', 'info handle', 'signal')
-------------------------------------------------

* Menu:

* handle::        Specify which signals to handle and show what's been set
* signal::        Send a signal to your program

A signal is an asynchronous event that can happen in a program.  The
operating system defines the possible kinds of signals, and gives each
kind a name and a number.  For example, in Unix 'SIGINT' is the signal a
program gets when you type an interrupt character (often 'C-c');
'SIGALRM' occurs when the alarm clock timer goes off (which happens only
if your program has requested an alarm).

   Some signal handlers are installed and changed for the BASH
debugger's normal use: 'SIGDEBUG' and 'SIGEXIT'.  'SIGDEBUG' is used by
the debugger to potentially stop your program before execution of each
statement occurs, and 'SIGEXIT' is used to catch your program just
before it is set to leave so you have the option of restarting the
program with the same options (and not leave the debugger) or let the
program quit.

   Signal handlers that the debugged script might have installed are
saved and called before the corresponding debugger handler.  Thus, the
debugged program should work roughly in the same fashion as when it is
not debugged.  However there are some call-stack variables which
inevitably will differ.  To try to hedge this a little so the behavior
is the same, the BASH debugger will modify arguments to the traps if it
finds one of the call-stack that change as a result of the debugger
being in place.  In particular '$LINENO' will get replaced with
'${BASH_LINENO[0]}'; also '${BASH_LINENO[0]}' and '${BASH_SOURCE[0]}'
get replaced with '${BASH_LINENO[1]}' and '${BASH_SOURCE[1]}'
respectively.

   The debugger also installs an interrupt handler 'SIGINT' so that
errant programs can be interrupted and you can find out where the
program was when you interrupted it.

   Some signals, including 'SIGALRM', are a normal part of the
functioning of your program.  Others, such as 'SIGSEGV', indicate
errors; these signals are "fatal" (they kill your program immediately)
if the program has not specified in advance some other way to handle the
signal.  'SIGINT' does not indicate an error in your program, but it is
normally fatal so it can carry out the purpose of the interrupt: to kill
the program.

   BASH has the ability to detect any occurrence of a signal in your
program.  You can tell BASH in advance what to do for each kind of
signal.

   Normally, BASH is set up to let the non-erroneous signals like
'SIGALRM' be silently passed to your program (so as not to interfere
with their role in the program's functioning) but to stop your program
immediately whenever an error signal happens.  You can change these
settings with the 'handle' command.


File: bashdb.info,  Node: handle,  Next: signal,  Up: Signals

4.4.3.1 Intercepting Signals ('handle', 'info handle')
......................................................

'handle SIGNAL KEYWORDS...'
     Change the way BASH handles signal SIGNAL.  SIGNAL can be the
     number of a signal or its name (with or without the 'SIG' at the
     beginning).  The KEYWORDS say what change to make.
'info signals'
'info handle'
     Print a table of all the kinds of signals and how BASH has been
     told to handle each one.  You can use this to see the signal
     numbers of all the defined types of signals.

     'info handle' is an alias for 'info signals'.

   The keywords allowed by the 'handle' command can be abbreviated.
Their full names are:

'stop'
     BASH should stop your program when this signal happens.  This
     implies the 'print' keyword as well.

'nostop'
     BASH should not stop your program when this signal happens.  It may
     still print a message telling you that the signal has come in.

'print'
     BASH should print a message when this signal happens.

'noprint'
     BASH should not mention the occurrence of the signal at all.

'stack'
     BASH should print a stack trace when this signal happens.

'nostack'
     BASH should not print a stack trace when this signal occurs.


File: bashdb.info,  Node: signal,  Prev: handle,  Up: Signals

4.4.3.2 Sending your program a signal ('signal')
................................................

'signal SIGNAL-NAME | SIGNAL-NUMBER'
     You can use the 'signal' command send a signal to your program.
     Supply either the signal name, e.g. 'SIGINT', or the signal number
     '15'.


File: bashdb.info,  Node: Stack,  Next: List,  Prev: Stopping,  Up: Debugger Command Reference

4.5 Examining the Stack Frame ('where', 'frame', 'up', 'down')
==============================================================

When your script has stopped, one thing you'll probably want to know is
where it stopped and some idea of how it got there.

   Each time your script performs a function call (either as part of a
command substitution or not), or 'source's a file, information about
this action is saved.  The call stack then is this a history of the
calls that got you to the point that you are currently stopped at.

   One of the stack frames is "selected" by the BASH debugger and many
the BASH debugger commands refer implicitly to the selected frame.  In
particular, whenever you ask the BASH debugger to list lines without
giving a line number or location the value is found in the selected
frame.  There are special the BASH debugger commands to select whichever
frame you are interested in.  *Note Selecting a frame: Selection.

   When your program stops, BASH automatically selects the currently
executing frame and describes it briefly, similar to the 'frame'
command.

* Menu:

* Frames::                      Stack frames
* Backtrace::                   Backtraces (where)
* Selection::                   Selecting a frame (up, down, frame)


File: bashdb.info,  Node: Frames,  Next: Backtrace,  Up: Stack

4.5.1 Stack frames
------------------

The call stack is divided up into contiguous pieces called "stack
frames", or "frames" for short; each frame is the data associated with
one call to one function.  The frame contains the line number of the
caller of the function, the source-file name that the line refers to a
function name (which could be the built-in name "source")..

   When your script is started, the stack has only one frame, that of
the function 'main'.  This is called the "initial" frame or the
"outermost" frame.  Each time a function is called, a new frame is made.
Each time a function returns, the frame for that function invocation is
eliminated.  If a function is recursive, there can be many frames for
the same function.  The frame for the function in which execution is
actually occurring is called the "innermost" frame.  This is the most
recently created of all the stack frames that still exist.

   the BASH debugger assigns numbers to all existing stack frames,
starting with zero for the innermost frame, one for the frame that
called it, and so on upward.  These numbers do not really exist in your
script; they are assigned by the BASH debugger to give you a way of
designating stack frames in the BASH debugger commands.


File: bashdb.info,  Node: Backtrace,  Next: Selection,  Prev: Frames,  Up: Stack

4.5.2 Backtraces ('where')
--------------------------

A backtrace is essentially the same as the call stack: a summary of how
your script got where it is.  It shows one line per frame, for many
frames, starting with the place that you are stopped at (frame zero),
followed by its caller (frame one), and on up the stack.

'backtrace'
'bt'
'where'
'T'
     Print a backtrace of the entire stack: one line per frame for all
     frames in the stack.

'backtrace N'
'bt N'
'where N'
'T N'
     Similar, but print only the innermost N frames.

   The names 'where' and 'T' are additional aliases for 'backtrace'.

   Each line in the backtrace shows the frame number and the function
name, the source file name and line number, as well as the function
name.

   Here is an example of a backtrace taken a program in the
regression-tests 'parm.sh'.

     % ../bashdb -n -L .. parm.sh
     Bourne-Again Shell Debugger, release 4.4-0.92
     Copyright 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2011 Rocky Bernstein
     This is free software, covered by the GNU General Public License, and you are
     welcome to change it and/or distribute copies of it under certain conditions.

     (./parm.sh:21):
     21:	fn1 5
     bashdb<0> continue fn3
     One-time breakpoint 1 set in file ./parm.sh, line 17.
     fn2: testing 1 2 3
     (./parm.sh:17):
     17:	fn3() {
     bashdb<1> where
     ->0 in file `./parm.sh' at line 14
     ##1 fn3() called from file `./parm.sh' at line 14
     ##2 fn2("testing 1", "2 3") called from file `parm.sh' at line 5
     ##3 fn1("0") called from file `parm.sh' at line 9
     ##4 fn1("1") called from file `parm.sh' at line 9
     ##5 fn1("2") called from file `parm.sh' at line 9
     ##6 fn1("3") called from file `parm.sh' at line 9
     ##7 fn1("4") called from file `parm.sh' at line 9
     ##8 fn1("5") called from file `parm.sh' at line 21
     ##9 source("parm.sh") called from file `bashdb' at line 143
     ##10 main("-n", "-L", "..", "parm.sh") called from file `bashdb' at line 0

The display for "frame" zero isn't a frame at all, although it has the
same information minus a function name; it just indicates that your
script has stopped at the code for line '14' of './parm.sh'.


File: bashdb.info,  Node: Selection,  Prev: Backtrace,  Up: Stack

4.5.3 Selecting a frame ('up', 'down', 'frame')
-----------------------------------------------

Commands for listing source code in your script work on whichever stack
frame is selected at the moment.  Here are the commands for selecting a
stack frame; all of them finish by printing a brief description of the
stack frame just selected.

'up [N]'
     Move N frames up the stack.  For positive numbers N, this advances
     toward the outermost frame, to higher frame numbers, to frames that
     have existed longer.  Using a negative N is the same as issuing a
     'down' command of the absolute value of the N.  Using zero for N
     does no frame adjustment, but since the current position is
     redisplayed, it may trigger a resynchronization if there is a front
     end also watching over things.

     N defaults to one.  You may abbreviate 'up' as 'u'.

'down [N]'
     Move N frames down the stack.  For positive numbers N, this
     advances toward the innermost frame, to lower frame numbers, to
     frames that were created more recently.  Using a negative N is the
     same as issuing a 'up' command of the absolute value of the N.
     Using zero for N does no frame adjustment, but since the current
     position is redisplayed, it may trigger a resynchronization if
     there is a front end also watching over things.

     N defaults to one.  You may abbreviate 'down' as 'do'.

   All of these commands end by printing two lines of output describing
the frame.  The first line shows the frame number, the function name,
the arguments, and the source file and line number of execution in that
frame.  The second line shows the text of that source line.

   For example:

     bashdb<8> up
     19:	sourced_fn
     bashdb<8> T
     ##0 in file `./bashtest-sourced' at line 8
     ->1 sourced_fn() called from file `bashtest-sourced' at line 19
     ##2 source() called from file `bashdb-test1' at line 23
     ##3 fn2() called from file `bashdb-test1' at line 33
     ##4 fn1() called from file `bashdb-test1' at line 42
     ##5 main() called from file `bashdb-test1' at line 0

   After such a printout, the 'list' command with no arguments prints
ten lines centered on the point of execution in the frame.  *Note
Printing source lines: List.

'frame ARGS'
     The 'frame' command allows you to move from one stack frame to
     another, and to print the stack frame you select.  ARGS is the the
     stack frame number; 'frame 0' then will always show the current and
     most recent stack frame.

     If a negative number is given, counting is from the other end of
     the stack frame, so 'frame -1' shows the least-recent, outermost or
     most "main" stack frame.

     Without an argument, 'frame' prints the current stack frame.  Since
     the current position is redisplayed, it may trigger a
     resynchronization if there is a front end also watching over
     things.


File: bashdb.info,  Node: List,  Next: Edit,  Prev: Stack,  Up: Debugger Command Reference

4.6 Examining Source Files ('list')
===================================

the BASH debugger can print parts of your script's source.  When your
script stops, the BASH debugger spontaneously prints the line where it
stopped.  Likewise, when you select a stack frame (*note Selecting a
frame: Selection.), the BASH debugger prints the line where execution in
that frame has stopped.  You can print other portions of source files by
explicit command.

   If you use the BASH debugger through its GNU Emacs interface, you may
prefer to use Emacs facilities to view source.

   To print lines from a source file, use the 'list' command
(abbreviated 'l').  By default, ten lines are printed.  There are
several ways to specify what part of the file you want to print.

   Here are the forms of the 'list' command most commonly used:

'list LINENUM'
'l LINENUM'
     Print lines centered around line number LINENUM in the current
     source file.

'list FUNCTION'
'l FUNCTION'
     Print the text of FUNCTION.

'list'
'l'
     Print more lines.  If the last lines printed were printed with a
     'list' command, this prints lines following the last lines printed;
     however, if the last line printed was a solitary line printed as
     part of displaying a stack frame (*note Examining the Stack:
     Stack.), this prints lines centered around that line.

'list -'
'l -'
     Print lines just before the lines last printed.

   By default, the BASH debugger prints ten source lines with any of
these forms of the 'list' command.  You can change this using 'set
listsize':

'set listsize COUNT'
     Make the 'list' command display COUNT source lines (unless the
     'list' argument explicitly specifies some other number).

'show listsize'
     Display the number of lines that 'list' prints.

   Repeating a 'list' command with <RET> discards the argument, so it is
equivalent to typing just 'list'.  This is more useful than listing the
same lines again.  An exception is made for an argument of '-'; that
argument is preserved in repetition so that each repetition moves up in
the source file.

   In general, the 'list' command expects you to supply a "linespecs".
Linespecs specify source lines; there are several ways of writing them,
but the effect is always to specify some source line.

   Here is a complete description of the possible arguments for 'list':

'list LINESPEC'
     Print lines centered around the line specified by LINESPEC.

'list FIRST INCREMENT'
     Print INCREMENT lines starting from FIRST

'list FIRST'
     Print lines starting with FIRST.

'list -'
     Print lines just before the lines last printed.

'list .'
     Print lines after where the script is stopped.

'list'
     As described in the preceding table.

   Here are the ways of specifying a single source line--all the kinds
of linespec.

'NUMBER'
     Specifies line NUMBER of the current source file.  When a 'list'
     command has two linespecs, this refers to the same source file as
     the first linespec.

'FILENAME:NUMBER'
     Specifies line NUMBER in the source file FILENAME.

'FUNCTION'
     Specifies the line that function FUNCTION is listed on.


File: bashdb.info,  Node: Edit,  Next: Search,  Prev: List,  Up: Debugger Command Reference

4.7 Editing Source files ('edit')
=================================

To edit the lines in a source file, use the 'edit' command.  The editing
program of your choice is invoked with the current line set to the
active line in the program.  Alternatively, you can give a line
specification to specify what part of the file you want to print if you
want to see other parts of the program.

   You can customize to use any editor you want by using the 'EDITOR'
environment variable.  The only restriction is that your editor (say
'ex'), recognizes the following command-line syntax:
     ex +NUMBER file
   The optional numeric value +NUMBER specifies the number of the line
in the file where to start editing.  For example, to configure the BASH
debugger to use the 'vi' editor, you could use these commands with the
'sh' shell:
     EDITOR=/usr/bin/vi
     export EDITOR
     gdb ...
   or in the 'csh' shell,
     setenv EDITOR /usr/bin/vi
     gdb ...

'edit [LINE SPECIFICATION]'
     Edit line specification using the editor specified by the 'EDITOR'
     environment variable.


File: bashdb.info,  Node: Search,  Next: Data,  Prev: Edit,  Up: Debugger Command Reference

4.8 Searching source files ('search', 'reverse', '/.../', '?..?')
=================================================================

There are two commands for searching through the current source file for
a BASH extended pattern-matching expression.

'forward BASH-PATTERN'
'search BASH-PATTERN'
     The command 'forward BASH-PATTERN' checks each line, starting with
     the one following the current line, for a match for BASH-PATTERN
     which is an extended bash pattern-matching expression.  It lists
     the line that is found.  You can use the synonym 'search
     BASH-PATTERN' or abbreviate the command name as 'fo' or '/PAT/'.

'reverse BASH-PATTERN'
     The command 'reverse BASH-PATTERN' checks each line, starting with
     the one before the last line listed and going backward, for a match
     for BASH-PATTERN.  It lists the line that is found.  You can
     abbreviate this command as 'rev' or '?BASH-PATTERN?'.


File: bashdb.info,  Node: Data,  Next: Auto Display,  Prev: Search,  Up: Debugger Command Reference

4.9 Examining Data ('print', 'examine', 'info variables')
=========================================================

One way to examine string data in your script is with the 'print'
command (abbreviated 'p').  However a more versatile print command is
'x'; it can print variable and function definitions and can do
arithmetic computations.  Finally, the most general method would be via
'eval echo'.

'print EXPR'

     Use 'print' to display strings as you would from 'echo'.  And as
     such, variable names to be substituted have to be preceded with a
     dollar sign.  As with echo, filename expansion, e.g. tilde
     expansion, is performed on unquoted strings.  So for example if you
     want to print a *, you would write 'print "*"', not 'print *'.  If
     you want to have the special characters dollars sign appear, use a
     backslash.

          bashdb<0> print the value of x is $x
          the value of x is 22
          bashdb<1> p The home directory for root is ~root
          The home directory for root is /root
          bashdb<2> p '*** You may have won $$$ ***'
          *** You may have won $$$ ***
          bashdb<3> # Note the use of the single quotes.
          bashdb<3> # Compare what happens with double quotes or no quotes

'print'
'p'
     If you omit EXPR, the BASH debugger displays the last expression
     again.

'x VARIABLE1 [VARIABLE2...]'
'x EXPR'

     This is a smarter, more versatile "print" command, and although
     sometimes it might not be what you want, and you may want to resort
     to either 'print' or 'eval echo...'.

     As with 'print', if you omit EXPR, the BASH debugger displays the
     last expression again.

     The 'x' command first checks if EXPR is variable or a list of
     variables delimited by spaces.  If it is, the definition(s) and
     value(s) of each printed via BASH's 'declare -p' command.  This
     will show the variable's attributes such as if it is read only or
     if it is an integer.  If the variable is an array, that is show and
     the array values are printed.

     If instead EXPR is a function, the function definition is printed
     via BASH's 'declare -f' command.  If EXPR was neither a variable
     nor an expression, then we try to get a value via 'let'.  And if
     this returns an error, as a last resort we call 'print' and give
     what it outputs.

     Since 'let' may be used internally and since (to my thinking) 'let'
     does funny things, the results may seem odd unless you understand
     the sequence tried above and how 'let' works.  For "example if the
     variable 'foo' has value 5, then 'x foo' shows the definition of
     foo with value 5, and 'x foo+5' prints 10 as expected.  So far so
     good.  However if 'foo' is has the value 'alpha', 'x foo+5' prints
     5 because 'let' has converted the string 'alpha' into the numeric
     value 0.  So 'p foo+5' will simply print "foo+5"; if you want the
     value of "foo" substituted inside a string, for example you expect
     "the value of foo is $foo" to come out "the value of foo is 5",
     then the right command to use is 'print' rather than 'x', making
     sure you add the dollar onto the beginning of the variable.

          bashdb<0> examine x y
          declare -- x="22"
          declare -- y="23"
          bashdb<1> examine x+y
          45
          bashdb<2> x fn1
          fn1 ()
          {
              echo "fn1 here";
              x=5;
              fn3
          }
          bashdb<2> x FUNCNAME
          declare -a FUNCNAME='([0]="_Dbg_cmd_x" [1]="_Dbg_cmdloop" [2]="_Dbg_debug_trap_handler" [3]="main")'

'V [!][PATTERN]'

     If you want to all list variables and values or a set of variables
     by pattern, use this command.

          bashdb<0> V dq*
          dq_args="dq_*"
          dq_cmd="V"
          bashdb<1> V FUNCNAME
          FUNCNAME='([0]="_Dbg_cmd_list_variables" [1]="_Dbg_cmdloop" [2]="_Dbg_debug_trap_handler" [3]="main")'


File: bashdb.info,  Node: Auto Display,  Next: Evaluation/Execution,  Prev: Data,  Up: Debugger Command Reference

4.10 Automatic display ('display', 'undisplay')
===============================================

If you find that you want to print the value of an expression frequently
(to see how it changes), you might want to add it to the "automatic
display list" so that the BASH debugger evaluates a statement each time
your program stops.  Each expression added to the list is given a number
to identify it; to remove an expression from the list, you specify that
number.  The automatic display looks like this:

     2 (echo $x): 38

This display shows item numbers, expressions and their current values.

'display EXPR'
     Add the expression EXPR to the list of expressions to display each
     time your program stops.

'display'
     Display the current values of the expressions on the list, just as
     is done when your program stops.

'undisplay DNUMS...'
'delete display DNUMS...'
     Remove item numbers DNUMS from the list of expressions to display.

     'undisplay' does not repeat if you press <RET> after using it.
     (Otherwise you would just get the error 'No display number ...'.)

'disable display DNUMS...'
     Disable the display of item numbers DNUMS.  A disabled display item
     is not printed automatically, but is not forgotten.  It may be
     enabled again later.

'enable display DNUMS...'
     Enable display of item numbers DNUMS.  It becomes effective once
     again in auto display of its expression, until you specify
     otherwise.

'info display'
     Print the list of expressions previously set up to display
     automatically, each one with its item number, but without showing
     the values.  This includes disabled expressions, which are marked
     as such.  It also includes expressions which would not be displayed
     right now because they refer to automatic variables not currently
     available.


File: bashdb.info,  Node: Evaluation/Execution,  Next: Interfacing to the OS,  Prev: Auto Display,  Up: Debugger Command Reference

4.11 Running Arbitrary BASH and Shell commands ('eval', 'shell')
================================================================

The two most general commands and most "low-level" are 'eval' and
'shell'.

'eval [ bash-code ]'
'e'

     In contrast to the commands of the last section the most general
     way to examine data is through 'eval'.  But you do much more with
     this; you can change the values of variables, since, you are just
     evaluating BASH code.

     If you expect output, you should arrange that in the command, such
     as via 'echo' or 'printf'.  For example, to print the value of FOO,
     you would type 'e echo $foo'.  This is bit longer than 'p $foo' or
     (when possible) 'x foo'.  However suppose you wanted to find out
     how the builtin test operator '[' works with the '-z' test
     condition.  You could use 'eval' to do this such as 'e [ -z "$foo"]
     && echo "yes"'.

'eval'

     I find I sometimes want to run the line that's about to be executed
     to see if I want to step into methods that are called.

     For example:

          (/etc/apparmor/functions:24):
          PROFILES="/etc/apparmor.d"
          bashdb<2>

     I had been cutting and pasting the command as shown, but realized I
     could do better if I made a command for this.  So that's what I've
     done.

     If you run the 'eval' command without any arguments, it will run
     the command that is about to be run.

          (/etc/apparmor/functions:24):
          PROFILES="/etc/apparmor.d"
          bashdb<2> eval
          eval: PROFILES="/etc/apparmor.d"
          $? is 0
          bashdb<3>

     This was working fine, until I started coming across tests inside
     'if', 'elsif', 'case', 'return' or 'while' blocks.  For example:

          (/etc/init.d/apparmor:70):
          if [ "$1" = "recache" ]

     Suppose I want to know which branch I'm going to take before taking
     the branch.  That way I might even be able to change which way to
     go by changing the test before it runs in the debugged program.
     (In the above example, I could print $1

          bashdb<2> pr $1
          status

     But I'm lazy.  I'd rather let the debugger do the work for me:

          bashdb<1> eval?
          eval: [ "$1" = "recache" ]
          $? is 1

     If you alias eval with a name that ends in ?  it will strip off any
     leading 'if', 'case', 'while', 'elsif', or 'return'.

'!! COMMAND STRING'

     If you need to execute occasional shell commands during your
     debugging session, there is no need to leave or suspend the BASH
     debugger; you can just use the 'shell' command or its alias '!!'.

     Invoke a shell to execute COMMAND STRING.

'shell'

     Although the debugger allows one to evaluate arbitrary BASH code
     using 'eval', or via the 'set autoeval' mode, sometimes you might
     prefer to work inside a BASH shell to see variables, experiment,
     issue commands (using the currently-set up environment), and even
     change variables and functions.

     For this we, the debugger 'shell' command, enters a nested shell
     session.  But before it does this, it saves out variable and
     function definitions in the current context of the running program.
     That way, you have access to those.

     This however creates a new problem: getting changes you make
     reflected back into the running program.  Right now any variable
     you change can be flagged to have its value re-read when the shell
     exits.  This is done using the 'save_var' function inside the
     nested shell.  'save_var' takes a list of variable names.

     Here is an example session

          bashdb /etc/init.d/apparmor status
          bashdb debugger, release 4.2-0.8

          Copyright 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2010, 2011 Rocky Bernstein
          This is free software, covered by the GNU General Public License, and you are
          welcome to change it and/or distribute copies of it under certain conditions.
          ...
          (/etc/init.d/apparmor:35):
          . /etc/apparmor/functions
          bashdb<1> s
          (/etc/apparmor/functions:24):
          PROFILES="/etc/apparmor.d"
          bashdb<2> s
          (/etc/apparmor/functions:25):
          PARSER="/sbin/apparmor_parser"
          bashdb<3> shell
          bashdb $ typeset -p PROFILES
          typeset -p PROFILES
          typeset PROFILES=/etc/apparmor.d
          bashdb $ PROFILES='Hi, Mom!'
          bashdb $ save_vars PROFILES
          bashdb $  <EOF>
          (/etc/apparmor/functions:25):
          PARSER="/sbin/apparmor_parser"
          bashdb<4> x PROFILES
          typeset PROFILES='Hi, Mom!'

     Note that inside the nested shell the we have set the prompt has
     been set to 'bashdb $ '.


File: bashdb.info,  Node: Interfacing to the OS,  Next: Information and Settings,  Prev: Evaluation/Execution,  Up: Debugger Command Reference

4.12 Interfacing to the OS ('cd', 'pwd')
========================================

'cd'

     Set working directory to DIRECTORY for debugger and program being
     debugged.  Tilde expansion, variable and filename expansion is
     performed on DIRECTORY.  If no directory is given, we print out the
     current directory which is really the same things as running 'pwd'.

     Note that 'gdb' is a little different in that it performs tilde
     expansion but not filename or variable expansion and the directory
     argument is not optional as it is here.

'pwd'

     Prints the working directory as the program sees things.


File: bashdb.info,  Node: Information and Settings,  Next: Controlling bashdb,  Prev: Interfacing to the OS,  Up: Debugger Command Reference

4.13 Status and Debugger Settings ('info', 'show')
==================================================

* Menu:

* Info::        Showing information about the program being debugged
* Show::        Show information about the debugger

In addition to 'help', you can use the BASH commands 'info' and 'show'
to inquire about the state of your program, or the state of BASH itself.
Each command supports many topics of inquiry; here we introduce each of
them in the appropriate context.  The listings under 'info' and under
'show' in the Index point to all the sub-commands.  *Note Command
Index::.


File: bashdb.info,  Node: Info,  Next: Show,  Up: Information and Settings

4.13.1 Showing information about the program being debugged ('info')
--------------------------------------------------------------------

This 'info' command (abbreviated 'i') is for describing the state of
your program.  For example, you can list the current '$1', '$2'
parameters with 'info args', or list the breakpoints you have set with
'info breakpoints' or 'info watchpoints'.  You can get a complete list
of the 'info' sub-commands with 'help info'.

'info args'
     Argument variables (e.g. $1, $2, ...)  of the current stack frame.
'info breakpoints'
     Status of user-settable breakpoints
'info display'
     Show all display expressions
'info files'
     Source files in the program
'info functions'
     All function names
'info line'
     list current line number and and file name
'info program'
     Execution status of the program.
'info signals'
     What debugger does when program gets various signals
'info source'
     Information about the current source file
'info stack'
     Backtrace of the stack
'info terminal'
     Print terminal device
'info variables'
     All global and static variable names


File: bashdb.info,  Node: Show,  Prev: Info,  Up: Information and Settings

4.13.2 Show information about the debugger ('show')
---------------------------------------------------

In contrast to 'info', 'show' is for describing the state of BASH
itself.  You can change most of the things you can 'show', by using the
related command 'set';

   The distinction between 'info' and 'show' however is a bit fuzzy and
is kept here to try to follow the GDB interface.  For example, to list
the arguments given to your script use 'show args'; 'info args' does
something different.

   Here are three miscellaneous 'show' subcommands, all of which are
exceptional in lacking corresponding 'set' commands:

'show version'
     Show what version of BASH is running.  You should include this
     information in BASH bug-reports.  If multiple versions of BASH are
     in use at your site, you may need to determine which version of
     BASH you are running; as BASH evolves, new commands are introduced,
     and old ones may wither away.  Also, many system vendors ship
     variant versions of BASH, and there are variant versions of BASH in
     GNU/Linux distributions as well.  The version number is the same as
     the one announced when you start BASH.

'show copying'
     Display information about permission for copying BASH.

'show linetrace'

     Show if line tracing is enabled.  See also *note Line Tracing::.

'show logging'

     Show summary information of logging variables which can be set via
     'set logging'.  See also *note Logging::.

'show logging file'

     Show the current logging file.

'show logging overwrite'

     Show whether logging overwrites or appends to the log file.

'show warranty'
     Display the GNU "NO WARRANTY" statement, or a warranty, if your
     version of the BASH debugger comes with one.


File: bashdb.info,  Node: Controlling bashdb,  Prev: Information and Settings,  Up: Debugger Command Reference

4.14 Controlling bashdb ('set', 'file', 'prompt', 'history'...)
===============================================================

You can alter the way BASH interacts with you in various ways given
below.

* Menu:

* Alias::                Debugger Command aliases
* Annotate::             Annotation Level (set annotate)
* Autoeval::             Evaluate unrecognized commands
* Autolist::             Run a list command on every stop
* Basename::             Show basenames of file names only (set basename)
* Debugger::             Allow debugging the debugger (set debugger)
* File::                 Specifying a Script-File Associaton (set file)
* Line Tracing::         Show position information (set linetrace)
* Logging::              Specifying where to write debugger output
* Prompt::               Prompt (set prompt, show prompt)
* Editing::              Command editing (set editing, show editing)
* Command-Tracing::      Showing commands as they run (set/show trace-commands)
* Command Display::      Command display (set showcommand)
* History::              Command history (history, !, H)
* Command Completion::   Command completion (complete)


File: bashdb.info,  Node: Alias,  Next: Annotate,  Up: Controlling bashdb

4.14.1 Debugger Command Aliases ('alias')
-----------------------------------------

'alias NAME COMMAND'
     Add NAME as an alias for COMMAND

     Remove NAME as an alias for COMMAND
'unalias NAME COMMAND'


File: bashdb.info,  Node: Annotate,  Next: Autoeval,  Prev: Alias,  Up: Controlling bashdb

4.14.2 Annotation Level ('set annotate')
----------------------------------------

'set annotate INTEGER'
     The annotation level controls how much information the BASH
     debugger prints in its prompt; right new it just controls whether
     we show full filenames in output or the base part of the filename
     without path information.  Level 0 is the normal, level 1 is for
     use when the BASH debugger is run as a subprocess of GNU Emacs of
     DDD, level 2 is the maximum annotation suitable for programs that
     control the BASH debugger.


File: bashdb.info,  Node: Autoeval,  Next: Autolist,  Prev: Annotate,  Up: Controlling bashdb

4.14.3 Set/Show auto-eval ('set autoeval')
------------------------------------------

'set autoeval [ on | 1 | off | 0 ]'
     Specify that debugger input that isn't recognized as a command
     should be passed to Ruby for evaluation (using the current debugged
     program namespace).  Note however that we _first_ check input to
     see if it is a debugger command and _only_ if it is not do we
     consider it as Ruby code.  This means for example that if you have
     variable called 'n' and you want to see its value, you could use 'p
     n', because just entering 'n' will be interpreted as the debugger
     "next" command.

     When autoeval is set on, you'll get a different error message when
     you invalid commands are encountered.  Here's a session fragment to
     show the difference
          bashdb<1> stepp
          Unknown command
          bashdb<2> set autoeval on
          autoeval is on.
          bashdb<3> stepp
          NameError Exception: undefined local variable or method `stepp' for ...

'show args'
     Shows whether Ruby evaluation of debugger input should occur or
     not.


File: bashdb.info,  Node: Autolist,  Next: Basename,  Prev: Autoeval,  Up: Controlling bashdb

4.14.4 Set/Show listing on stop ('set autolist')
------------------------------------------------

'set autolist [ on | 1 | off | 0 ]'
     When set runs a "list" command on each stop in the debugger.


File: bashdb.info,  Node: Basename,  Next: Debugger,  Prev: Autolist,  Up: Controlling bashdb

4.14.5 File basename ('set basename')
-------------------------------------

'set basename [ on | 1 ]'
     When set on, source filenames are shown as the shorter "basename"
     only.  (Directory paths are omitted).  This is useful in running
     the regression tests and may useful in showing debugger examples as
     in this text.  You may also just want less verbose filename
     display.

'set basename [ off | 0 ]'
     Source filenames are shown as with their full path.  This is the
     default.


File: bashdb.info,  Node: Debugger,  Next: File,  Prev: Basename,  Up: Controlling bashdb

4.14.6 Allow Debugging the debugger ('set debugger')
----------------------------------------------------

'set debugger [ on | 1 ]'
     Allow the possibility of debugging this debugger.  Somewhat of an
     arcane thing to do.  For gurus, and even he doesn't use it all that
     much.
'set debugger [ off | 0 ]'
     Don't allow debugging into the debugger.  This is the default.


File: bashdb.info,  Node: File,  Next: Line Tracing,  Prev: Debugger,  Up: Controlling bashdb

4.14.7 Specifying a Script-File Association ('file')
----------------------------------------------------

Sometimes the BASH debugger gets confused about where to find the script
source file for the name reported to it by bash.  To resolve relative
file names that bash supplies via 'BASH_SOURCE', the BASH debugger uses
the current working directory when the debugged script was started as
well as the current working directory now (which might be different if a
"cd" command was issued to change the working directory).

   However sometimes this doesn't work and there is a way to override
this.

'file SCRIPT-FILE'
     Directs the BASH debugger to use SCRIPT-FILE whenever bash would
     have it refers to the filename given in 'BASH_SOURCE'.  The
     filename specified in 'BASH_SOURCE' that gets overridden is shown
     when is this command is issued.


File: bashdb.info,  Node: Line Tracing,  Next: Logging,  Prev: File,  Up: Controlling bashdb

4.14.8 Show position information as statements are executed ('set linetrace')
-----------------------------------------------------------------------------

BASH has "'set -x'" tracing to show commands as they are run.  However
missing from this is file and line position information.  So the
debugger compensates here for what I think is deficiency of BASH by
providing this information.  The downside is that this tracing is slower
than the built-in tracing of BASH.

   The status of whether line tracing is enabled can be show via 'show
linetrace'.

'set linetrace [ on | 1 ]'
     Turn on line tracing.
'set linetrace [ off | 0 ]'
     Turn off line tracing.


File: bashdb.info,  Node: Logging,  Next: Prompt,  Prev: Line Tracing,  Up: Controlling bashdb

4.14.9 Logging output ('set logging', 'set logging file'...)
------------------------------------------------------------

You may want to save the output of the debugger commands to a file.
There are several commands to control the debuggers's logging.

'set logging'
     Prints 'set logging' usage.
'set logging [ on | 1 ]'
     Enable or Disable logging.
'set logging file FILENAME'
     Change the name of the current logfile.  The default logfile is
     'bashdb.txt'.
'set logging overwrite [ on | 1 ]'
     By default, the debugger will append to the logfile.  Set
     'overwrite' if you want 'set logging on' to overwrite the logfile
     instead.
'set logging redirect [ on | 1 ]'
     By default, the debugger output will go to both the terminal and
     the logfile.  Set 'redirect' if you want output to go only to the
     log file.
'show logging'
     Show the current values of the logging settings.


File: bashdb.info,  Node: Prompt,  Next: Editing,  Prev: Logging,  Up: Controlling bashdb

4.14.10 Prompt ('set prompt', 'show prompt')
--------------------------------------------

The BASH debugger indicates its readiness to read a command by printing
a string called the "prompt".  This string is normally:
     bashdb${_Dbg_less}${#_Dbg_history[@]}${_Dbg_greater}$_Dbg_space

   When variables inside the the prompt string are evaluated, the above
becomes something like 'bashdb<5>' if this is the fifth command executed
or perhaps 'bashdb<<2>>' if you have called the debugger from inside a
debugger session and this is the second command inside the debugger
session or perhaps 'bashdb<(6)>' if you entered a subshell after the
fifth command.

   You can change the prompt string with the 'set prompt' command,
although it is not normally advisable to do so without understanding the
implications.  If you are using the DDD GUI, it changes the changes the
prompt and should not do so.  In certain other circumstances (such as
writing a GUI like DDD), it may be is useful to change the prompt.

   _Note:_ 'set prompt' does not add a space for you after the prompt
you set.  This allows you to set a prompt which ends in a space or a
prompt that does not.  Furthermore due to a implementation limitation
(resulting from a limitation of the bash built-in function "read"), to
put a space at the end of the prompt use the '$_Dbg_space' variable.

'set prompt NEWPROMPT'
     Directs the BASH debugger to use NEWPROMPT as its prompt string
     henceforth.

     _Warning: changing the prompt can DDD's ability to understand when
     the debugger is waiting for input._

'show prompt'
     Prints a line of the form: 'bashdb's prompt is: YOUR-PROMPT'


File: bashdb.info,  Node: Editing,  Next: Command-Tracing,  Prev: Prompt,  Up: Controlling bashdb

4.14.11 Command editing ('set editing', 'show editing')
-------------------------------------------------------

the BASH debugger reads its input commands through bash which uses via
the "readline" interface.  This GNU library provides consistent behavior
for programs which provide a command line interface to the user.
Advantages are GNU Emacs-style or "vi"-style inline editing of commands,
'csh'-like history substitution, and a storage and recall of command
history across debugging sessions.

   You may control the behavior of command line editing in BASH with the
command 'set'.

'set editing'
'set editing [ on | 1 ]'
     Enable command line editing (enabled by default).

'set editing [ off | 0 ]'
     Disable command line editing.

'show editing'
     Show whether command line editing is enabled.


File: bashdb.info,  Node: Command-Tracing,  Next: Command Display,  Prev: Editing,  Up: Controlling bashdb

4.14.12 Debugger Commands Tracing ('set trace-commands', 'show trace-commands')
-------------------------------------------------------------------------------

If you need to debug user-defined commands or sourced files you may find
it useful to enable "command tracing".  In this mode each command will
be printed as it is executed, prefixed with one or more '+' symbols, the
quantity denoting the call depth of each command.

'set trace-commands on'
     Enable command tracing.
'set trace-commands off'
     Disable command tracing.
'show trace-commands'
     Display the current state of command tracing.


File: bashdb.info,  Node: Command Display,  Next: History,  Prev: Command-Tracing,  Up: Controlling bashdb

4.14.13 Command Display ('set showcommand')
-------------------------------------------

The debugger normally lists the line number and source line of the for
the statement to be next executed.  Often this line contains one
expression or one statement and it is clear from this line what's going
to happen.  However BASH allows many expressions or statements to be put
on a single source line; some lines contain several units of execution.
Some examples of this behavior are listed below:

     x=1; y=2; x=3
     (( x > 5 )) && x=5
     y=`echo *`

   In the first line of the example above, we have three assignment
statements on a single line.  In the second line of the example above we
have a statement which gets run only if a condition tests true.  And in
the third line of the example above, we have a command that gets run and
then the output of that is substituted in an assignment statement.  If
you were single stepping inside the debugger, each line might get listed
more than once before each of the actions that might get performed.  (In
the case of the conditional statement, the line gets listed only once
when the condition is false.)

   In order to assist understanding where you are, the enhanced version
of BASH maintains a dynamic variable 'BASH_COMMAND' that contains piece
of code next to be run (or is currently being run).  The debugger has
arranged to save this and can display this information or not.  This is
controlled by 'set showcommand'.

'set showcommand [auto | on | 1 | off | 0 ]'
     controls whether or not to show the saved 'BASH_COMMAND' for the
     command next to be executed.

   When the value is 'auto' the following heuristic is used to determine
whether or not to display the saved 'BASH_COMMAND'.  If the last time
you stopped you were at the same place and the command string has
changed, then show the command.  When the value 'on' is used, the
debugger always shows 'BASH_COMMAND' and when 'off' is used, the
debugger never shows 'BASH_COMMAND'.  Note that listing the text of the
source line is independent of whether or not the command is also listed.

   Some examples:
     set showcommand auto      This is the default
     set showcommand on        Always show the next command to be executed
     set showcommand off       Never show the next command to be executed


File: bashdb.info,  Node: History,  Next: Command Completion,  Prev: Command Display,  Up: Controlling bashdb

4.14.14 Command history ('H', 'history', '!')
---------------------------------------------

The BASH debugger can keep track of the commands you type during your
debugging sessions, so that you can be certain of precisely what
happened.  If the prompt has not been changed (see *note Prompt:
Prompt.), the history number that will be in use next is by default
listed in the debugger prompt.  Invalid commands and history commands
are not saved on the history stack.

'H [START-NUMBER [END-NUMBER]]'
'H [-COUNT]'
'![-]N:p'

     You can list what is in the history stack with 'H'.  Debugger
     commands in the history stack are listed from most recent to least
     recent.  If no START-NUMBER is given we start with the most
     recently executed command and end with the first entry in the
     history stack.  If START-NUMBER is given, that history number is
     listed first.  If END-NUMBER is given, that history number is
     listed last.  If a single negative number is given list that many
     history commands.

     An alternate form is '!_n_:p' or '!-_n_:p' where _n_ is an integer.
     If a minus sign is used, _n_ is taken as the count to go back from
     the end rather than as a absolute history number.  In contrast 'H',
     this form only prints a _single_ history item.

     Some examples:
          H      List entire history
          H -2   List the last two history items
          !-2:p  List a single history item starting at the same place as above
          H 5    List history from history number 5 to the beginning (number 0)
          H 5 0  Same as above
          H 5 3  List history from history number 5 down to history number 3
          !5:p   List a single history item 5

'history [[-]N]'
'![-]N'

     Use this command to reexecute a given history number.  If no number
     is given, the last debugger command in the history is executed.

     An alternate form is '!_n_' or '!-_n_' where _n_ is an integer.

     If a minus sign is used in in either form, _n_ is taken as the
     count to go back from the end rather than as a absolute history
     number.

   Use these commands to manage the the BASH debugger command history
facility.

'set history save'
'set history save [ on | 1 ]'
     Record command history in a file, whose name may be specified with
     the 'set history filename' command.  By default, this option is
     enabled.

'set history save [ off | 0 ]'
     Stop recording command history in a file.

'set history size SIZE'
     Set the number of commands which BASH keeps in its history list.
     This defaults to the value of the environment variable 'HISTSIZE',
     or to 256 if this variable is not set.

'show history'
'show history save'
'show history size'
     These commands display the state of the BASH history parameters.
     'show history' by itself displays all states.

'show commands'
     Display the last ten commands in the command history.

'show commands N'
     Print ten commands centered on command number N.

'show commands +'
     Print ten commands just after the commands last printed.


File: bashdb.info,  Node: Command Completion,  Prev: History,  Up: Controlling bashdb

4.14.15 Command Completion ('complete')
---------------------------------------

The 'complete ARGS' command lists all the possible completions for the
beginning of a command.  We can also show completions for 'set', 'show'
and 'info' subcommands.  Use ARGS to specify the beginning of the
command you want completed.  For example:

     complete d

results in:

     d
     debug
     delete
     disable
     display
     deleteall
     down

   And
     complete set a

results in:

     set args
     set annotate

This is intended for use by front-ends such as GNU Emacs and DDD.


File: bashdb.info,  Node: BASH Debugger Bugs,  Next: History and Acknowledgments,  Prev: Debugger Command Reference,  Up: Top

5 Reporting Bugs
****************

Your bug reports play an essential role in making the BASH debugger
reliable.

   Reporting a bug may help you by bringing a solution to your problem,
or it may not.  But in any case the principal function of a bug report
is to help the entire community by making the next version of the BASH
debugger work better.  Bug reports are your contribution to the
maintenance of the BASH debugger.

   In order for a bug report to serve its purpose, you must include the
information that enables us to fix the bug.

* Menu:

* Bug Criteria::                Have you found a bug?
* Bug Reporting::               How to report bugs


File: bashdb.info,  Node: Bug Criteria,  Next: Bug Reporting,  Up: BASH Debugger Bugs

5.1 Have you found a bug?
=========================

If you are not sure whether you have found a bug, here are some
guidelines:

   * If the debugger gets a fatal signal, for any input whatever, that
     is a the BASH debugger bug.  Reliable debuggers never crash.

   * If the BASH debugger produces an error message for valid input,
     that is a bug.  (Note that if you're cross debugging, the problem
     may also be somewhere in the connection to the target.)

   * If the BASH debugger does not produce an error message for invalid
     input, that is a bug.  However, you should note that your idea of
     "invalid input" might be our idea of "an extension" or "support for
     traditional practice".

   * If you are an experienced user of debugging tools, your suggestions
     for improvement of the BASH debugger are welcome in any case.


File: bashdb.info,  Node: Bug Reporting,  Prev: Bug Criteria,  Up: BASH Debugger Bugs

5.2 How to report bugs
======================

Bug reports can sent via the sourceforge bug tracking mechanism at
<http://sourceforge.net/tracker/?group_id=61395&atid=497159>.  Of course
patches are very much welcome too.  Those can also be sent via the same
mechanism.

   The fundamental principle of reporting bugs usefully is this: *report
all the facts*.  If you are not sure whether to state a fact or leave it
out, state it!

   Often people omit facts because they think they know what causes the
problem and assume that some details do not matter.  Thus, you might
assume that the name of the variable you use in an example does not
matter.  Well, probably it does not, but one cannot be sure.  Perhaps
the bug is a stray memory reference which happens to fetch from the
location where that name is stored in memory; perhaps, if the name were
different, the contents of that location would fool the debugger into
doing the right thing despite the bug.  Play it safe and give a
specific, complete example.  That is the easiest thing for you to do,
and the most helpful.

   Keep in mind that the purpose of a bug report is to enable us to fix
the bug.  It may be that the bug has been reported previously, but
neither you nor we can know that unless your bug report is complete and
self-contained.

   Sometimes people give a few sketchy facts and ask, "Does this ring a
bell?"  Those bug reports are useless, and we urge everyone to _refuse
to respond to them_ except to chide the sender to report bugs properly.

   To enable us to fix the bug, you should include all these things:

   * The version of the BASH debugger.  the BASH debugger announces it
     if you start with no arguments; you can also print it at any time
     using 'version' command.

     Without this, we will not know whether there is any point in
     looking for the bug in the current version of the BASH debugger.

   * The type of machine you are using, and the operating system name
     and version number.

   * What compiler (and its version) was used to compile BASH--e.g.
     "gcc 3.4".

   * The command arguments you gave the compiler to compile your example
     and observe the bug.  For example, did you use '-O'?  To guarantee
     you will not omit something important, list them all.  A copy of
     the Makefile (or the output from make) is sufficient.

     If we were to try to guess the arguments, we would probably guess
     wrong and then we might not encounter the bug.

   * A complete input script, and all necessary source files, that will
     reproduce the bug.

   * A description of what behavior you observe that you believe is
     incorrect.  For example, "It gets a fatal signal."

     Of course, if the bug is that the BASH debugger gets a fatal
     signal, then we will certainly notice it.  But if the bug is
     incorrect output, we might not notice unless it is glaringly wrong.
     You might as well not give us a chance to make a mistake.

     Even if the problem you experience is a fatal signal, you should
     still say so explicitly.  Suppose something strange is going on,
     such as, your copy of the BASH debugger is out of synch, or you
     have encountered a bug in the C library on your system.  (This has
     happened!)  Your copy might crash and ours would not.  If you told
     us to expect a crash, then when ours fails to crash, we would know
     that the bug was not happening for us.  If you had not told us to
     expect a crash, then we would not be able to draw any conclusion
     from our observations.

   * If you wish to suggest changes to the the BASH debugger source,
     send us context diffs.  If you even discuss something in the the
     BASH debugger source, refer to it by context, not by line number.

     The line numbers in our development sources will not match those in
     your sources.  Your line numbers would convey no useful information
     to us.

   Here are some things that are not necessary:

   * A description of the envelope of the bug.

     Often people who encounter a bug spend a lot of time investigating
     which changes to the input file will make the bug go away and which
     changes will not affect it.

     This is often time consuming and not very useful, because the way
     we will find the bug is by running a single example under the
     debugger with breakpoints, not by pure deduction from a series of
     examples.  We recommend that you save your time for something else.

     Of course, if you can find a simpler example to report _instead_ of
     the original one, that is a convenience for us.  Errors in the
     output will be easier to spot, running under the debugger will take
     less time, and so on.

     However, simplification is not vital; if you do not want to do
     this, report the bug anyway and send us the entire test case you
     used.

   * A patch for the bug.

     A patch for the bug does help us if it is a good one.  But do not
     omit the necessary information, such as the test case, on the
     assumption that a patch is all we need.  We might see problems with
     your patch and decide to fix the problem another way, or we might
     not understand it at all.

     Sometimes with a program as complicated as the BASH debugger it is
     very hard to construct an example that will make the program follow
     a certain path through the code.  If you do not send us the
     example, we will not be able to construct one, so we will not be
     able to verify that the bug is fixed.

     And if we cannot understand what bug you are trying to fix, or why
     your patch should be an improvement, we will not install it.  A
     test case will help us to understand.

   * A guess about what the bug is or what it depends on.

     Such guesses are usually wrong.  Even we cannot guess right about
     such things without first using the debugger to find the facts.


File: bashdb.info,  Node: History and Acknowledgments,  Next: Copying,  Prev: BASH Debugger Bugs,  Up: Top

6 History and Acknowledgments
*****************************

The suggestion for a debugger for a Bourne-like shell came from the book
"Learning the Korn Shell", by Bill Rosenblatt Copyright (C) 1993 by
O'Reilly and Associates, Inc.  Others such as Cigy Cyriac, Chet Ramey,
Rocky Bernstein, and Gary V. Vaughan expanded and improved on that.

   However Bourne-Shell debuggers rely on a signal mechanism
('SIGDEBUG') to call a debugger routine.  In the Korn shell as well as
BASH in versions prior to 2.05, there was a fundamental flaw: the
routine that you registered in the trap, got called _after_ the
statement was executed.  It takes little imagination to realize that
this is a bit too late to find and correct errors, especially if the
offending command happens to do serious damage like remove filesystems
or reboot a server.  As a horrible hack, these debuggers added one to
the line number that was just executed on the wishful thinking that this
would then be the line of next statement to execute.  Sometimes this was
correct, but it was too often wrong, such as in loops and conditionals,
comments, or commands that are continued on the next line.

   Another failing of these debuggers was the inability to debug into
functions or into sourced files, provide a stack trace, dynamically skip
a statement to be run, unconditionally trace into a function or
subshell, or stop when a subroutine, sourced file, or subshell
completed.  In truth, the crux of the problem lay in debugging support
in BASH. Given that there was limited bash debugging support, it is not
surprising that these debuggers could not do any of the things listed
above and could debug only a single shell in a single source file: lines
could be listed only from a single text, breakpoints were set into the
text which was in fact a copy of the script name prepended with debugger
routines.

   In version 2.04 of BASH, Rocky Bernstein started hacking on BASH to
add call-stack information, source file information, allow for debugging
into functions and for reporting line numbers in functions as relative
to the file rather than the beginning of a function whose origin line
number was not accessible from BASH. He started changing the user
commands in bashdb to be like other more-advanced debuggers, in
particular 'perl5db' and 'gdb'.  However he gave up on this project when
realizing that stopping before a line was crucial.  A patch for this was
nontrivial and wildly changed semantics.  Furthermore the chance of
getting his other patches into BASH was was not going to happen in
version 2.04.

   In version 2.05, the fundamental necessary change to the semantics of
'SIGDEBUG' trap handling (suggested at least two years earlier) was
made.  Also, version 2.05 changed the line-number reporting in a
function to be relative to the beginning of the file rather than the
beginning of a function--sometimes.  Rocky then picked up where he left
off and this then became this debugger.  A complete rewrite of the
debugger, some of which started in 2.04 was undertaken.  Debugger
internals were changed to support multiple file names, save and restore
the calling environment (such as variables '$1' and '$?') and install
debugger signal handlers.  Work was also done on the BASH in conjunction
with the debugger to save stack trace information, provide a means for
stopping after a routine finished, debugging into a subshell and so on.
And a number of changes were made to BASH just to improve the accuracy
of the line number reporting which is crucial in a debugger.

   This documentation was modified from the GNU Debugger (GDB) Reference
manual.

     Additions to this section are particularly welcome.  If you or your
     friends (or enemies, to be evenhanded) have been unfairly omitted
     from this list, we would like to add your names!

   The following have contributed directly or indirectly to _bashdb_:

   Rocky Bernstein (initial full-featured bashdb with stack tracing and
multi-file support)

   Masatake YAMATO (help to merge Rocky's hack to the official bash
source tree)

   Rod Smith (for creating and hosting a nicely formatted version of
this manual that you are probably reading online)

   Bill Rosenblatt (kshdb), Michael Loukides (kshdb), Cigy Cyriac (proto
bashdb), Chet Ramey (proto bashdb), and Gary V. Vaughan (proto bashdb).

   Authors of per5ldb:

   Ray Lischner, Johan Vromans, and Ilya Zakharevich.

   Authors of GDB:

   Richard Stallman, Andrew Cagney, Jim Blandy, Jason Molenda, Stan
Shebs, Fred Fish, Stu Grossman, John Gilmore, Jim Kingdon, and Randy
Smith (to name just a few).

   Authors of GUD:

   Eric S. Raymond.


File: bashdb.info,  Node: Copying,  Next: GNU Free Documentation License,  Prev: History and Acknowledgments,  Up: Top

Appendix A GNU GENERAL PUBLIC LICENSE
*************************************

                         Version 2, June 1991

     Copyright (C) 1989, 1991 Free Software Foundation, Inc.
     59 Temple Place - Suite 330, Boston, MA 02111-1307, USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

Preamble
========

The licenses for most software are designed to take away your freedom to
share and change it.  By contrast, the GNU General Public License is
intended to guarantee your freedom to share and change free software--to
make sure the software is free for all its users.  This General Public
License applies to most of the Free Software Foundation's software and
to any other program whose authors commit to using it.  (Some other Free
Software Foundation software is covered by the GNU Library General
Public License instead.)  You can apply it to your programs, too.

   When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it if
you want it, that you can change the software or use pieces of it in new
free programs; and that you know you can do these things.

   To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

   For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

   We protect your rights with two steps: (1) copyright the software,
and (2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

   Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

   Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

   The precise terms and conditions for copying, distribution and
modification follow.

    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains a
     notice placed by the copyright holder saying it may be distributed
     under the terms of this General Public License.  The "Program",
     below, refers to any such program or work, and a "work based on the
     Program" means either the Program or any derivative work under
     copyright law: that is to say, a work containing the Program or a
     portion of it, either verbatim or with modifications and/or
     translated into another language.  (Hereinafter, translation is
     included without limitation in the term "modification".)  Each
     licensee is addressed as "you".

     Activities other than copying, distribution and modification are
     not covered by this License; they are outside its scope.  The act
     of running the Program is not restricted, and the output from the
     Program is covered only if its contents constitute a work based on
     the Program (independent of having been made by running the
     Program).  Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's source
     code as you receive it, in any medium, provided that you
     conspicuously and appropriately publish on each copy an appropriate
     copyright notice and disclaimer of warranty; keep intact all the
     notices that refer to this License and to the absence of any
     warranty; and give any other recipients of the Program a copy of
     this License along with the Program.

     You may charge a fee for the physical act of transferring a copy,
     and you may at your option offer warranty protection in exchange
     for a fee.

  2. You may modify your copy or copies of the Program or any portion of
     it, thus forming a work based on the Program, and copy and
     distribute such modifications or work under the terms of Section 1
     above, provided that you also meet all of these conditions:

       a. You must cause the modified files to carry prominent notices
          stating that you changed the files and the date of any change.

       b. You must cause any work that you distribute or publish, that
          in whole or in part contains or is derived from the Program or
          any part thereof, to be licensed as a whole at no charge to
          all third parties under the terms of this License.

       c. If the modified program normally reads commands interactively
          when run, you must cause it, when started running for such
          interactive use in the most ordinary way, to print or display
          an announcement including an appropriate copyright notice and
          a notice that there is no warranty (or else, saying that you
          provide a warranty) and that users may redistribute the
          program under these conditions, and telling the user how to
          view a copy of this License.  (Exception: if the Program
          itself is interactive but does not normally print such an
          announcement, your work based on the Program is not required
          to print an announcement.)

     These requirements apply to the modified work as a whole.  If
     identifiable sections of that work are not derived from the
     Program, and can be reasonably considered independent and separate
     works in themselves, then this License, and its terms, do not apply
     to those sections when you distribute them as separate works.  But
     when you distribute the same sections as part of a whole which is a
     work based on the Program, the distribution of the whole must be on
     the terms of this License, whose permissions for other licensees
     extend to the entire whole, and thus to each and every part
     regardless of who wrote it.

     Thus, it is not the intent of this section to claim rights or
     contest your rights to work written entirely by you; rather, the
     intent is to exercise the right to control the distribution of
     derivative or collective works based on the Program.

     In addition, mere aggregation of another work not based on the
     Program with the Program (or with a work based on the Program) on a
     volume of a storage or distribution medium does not bring the other
     work under the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
     under Section 2) in object code or executable form under the terms
     of Sections 1 and 2 above provided that you also do one of the
     following:

       a. Accompany it with the complete corresponding machine-readable
          source code, which must be distributed under the terms of
          Sections 1 and 2 above on a medium customarily used for
          software interchange; or,

       b. Accompany it with a written offer, valid for at least three
          years, to give any third party, for a charge no more than your
          cost of physically performing source distribution, a complete
          machine-readable copy of the corresponding source code, to be
          distributed under the terms of Sections 1 and 2 above on a
          medium customarily used for software interchange; or,

       c. Accompany it with the information you received as to the offer
          to distribute corresponding source code.  (This alternative is
          allowed only for noncommercial distribution and only if you
          received the program in object code or executable form with
          such an offer, in accord with Subsection b above.)

     The source code for a work means the preferred form of the work for
     making modifications to it.  For an executable work, complete
     source code means all the source code for all modules it contains,
     plus any associated interface definition files, plus the scripts
     used to control compilation and installation of the executable.
     However, as a special exception, the source code distributed need
     not include anything that is normally distributed (in either source
     or binary form) with the major components (compiler, kernel, and so
     on) of the operating system on which the executable runs, unless
     that component itself accompanies the executable.

     If distribution of executable or object code is made by offering
     access to copy from a designated place, then offering equivalent
     access to copy the source code from the same place counts as
     distribution of the source code, even though third parties are not
     compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense or distribute the Program is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses terminated
     so long as such parties remain in full compliance.

  5. You are not required to accept this License, since you have not
     signed it.  However, nothing else grants you permission to modify
     or distribute the Program or its derivative works.  These actions
     are prohibited by law if you do not accept this License.
     Therefore, by modifying or distributing the Program (or any work
     based on the Program), you indicate your acceptance of this License
     to do so, and all its terms and conditions for copying,
     distributing or modifying the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
     Program), the recipient automatically receives a license from the
     original licensor to copy, distribute or modify the Program subject
     to these terms and conditions.  You may not impose any further
     restrictions on the recipients' exercise of the rights granted
     herein.  You are not responsible for enforcing compliance by third
     parties to this License.

  7. If, as a consequence of a court judgment or allegation of patent
     infringement or for any other reason (not limited to patent
     issues), conditions are imposed on you (whether by court order,
     agreement or otherwise) that contradict the conditions of this
     License, they do not excuse you from the conditions of this
     License.  If you cannot distribute so as to satisfy simultaneously
     your obligations under this License and any other pertinent
     obligations, then as a consequence you may not distribute the
     Program at all.  For example, if a patent license would not permit
     royalty-free redistribution of the Program by all those who receive
     copies directly or indirectly through you, then the only way you
     could satisfy both it and this License would be to refrain entirely
     from distribution of the Program.

     If any portion of this section is held invalid or unenforceable
     under any particular circumstance, the balance of the section is
     intended to apply and the section as a whole is intended to apply
     in other circumstances.

     It is not the purpose of this section to induce you to infringe any
     patents or other property right claims or to contest validity of
     any such claims; this section has the sole purpose of protecting
     the integrity of the free software distribution system, which is
     implemented by public license practices.  Many people have made
     generous contributions to the wide range of software distributed
     through that system in reliance on consistent application of that
     system; it is up to the author/donor to decide if he or she is
     willing to distribute software through any other system and a
     licensee cannot impose that choice.

     This section is intended to make thoroughly clear what is believed
     to be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
     certain countries either by patents or by copyrighted interfaces,
     the original copyright holder who places the Program under this
     License may add an explicit geographical distribution limitation
     excluding those countries, so that distribution is permitted only
     in or among countries not thus excluded.  In such case, this
     License incorporates the limitation as if written in the body of
     this License.

  9. The Free Software Foundation may publish revised and/or new
     versions of the General Public License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies a version number of this License which applies to
     it and "any later version", you have the option of following the
     terms and conditions either of that version or of any later version
     published by the Free Software Foundation.  If the Program does not
     specify a version number of this License, you may choose any
     version ever published by the Free Software Foundation.

  10. If you wish to incorporate parts of the Program into other free
     programs whose distribution conditions are different, write to the
     author to ask for permission.  For software which is copyrighted by
     the Free Software Foundation, write to the Free Software
     Foundation; we sometimes make exceptions for this.  Our decision
     will be guided by the two goals of preserving the free status of
     all derivatives of our free software and of promoting the sharing
     and reuse of software generally.

                              NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO
     WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE
     LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS
     AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
     OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT
     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
     FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND
     PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE
     DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR
     OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
     MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE
     LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
     INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
     INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
     DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU
     OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY
     OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN
     ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

                      END OF TERMS AND CONDITIONS

How to Apply These Terms to Your New Programs
=============================================

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND A BRIEF IDEA OF WHAT IT DOES.
     Copyright (C) YEAR  NAME OF AUTHOR

     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place - Suite 330,
     Boston, MA 02111-1307, USA.

   Also add information on how to contact you by electronic and paper
mail.

   If the program is interactive, make it output a short notice like
this when it starts in an interactive mode:

     Gnomovision version 69, Copyright (C) YEAR NAME OF AUTHOR
     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details
     type `show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type `show c' for details.

   The hypothetical commands 'show w' and 'show c' should show the
appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than 'show w' and 'show
c'; they could even be mouse-clicks or menu items--whatever suits your
program.

   You should also get your employer (if you work as a programmer) or
your school, if any, to sign a "copyright disclaimer" for the program,
if necessary.  Here is a sample; alter the names:

     Yoyodyne, Inc., hereby disclaims all copyright interest in the program
     `Gnomovision' (which makes passes at compilers) written by James Hacker.

     SIGNATURE OF TY COON, 1 April 1989
     Ty Coon, President of Vice

   This General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use the
GNU Library General Public License instead of this License.


File: bashdb.info,  Node: GNU Free Documentation License,  Next: Command Index,  Prev: Copying,  Up: Top

Appendix B GNU Free Documentation License
*****************************************

                        Version 1.1, March 2000

     Copyright (C) 2000  Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     written document "free" in the sense of freedom: to assure everyone
     the effective freedom to copy and redistribute it, with or without
     modifying it, either commercially or noncommercially.  Secondarily,
     this License preserves for the author and publisher a way to get
     credit for their work, while not being considered responsible for
     modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.  We
     recommend this License principally for works whose purpose is
     instruction or reference.


  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work that contains a
     notice placed by the copyright holder saying it can be distributed
     under the terms of this License.  The "Document", below, refers to
     any such manual or work.  Any member of the public is a licensee,
     and is addressed as "you."

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document's overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (For example, if the
     Document is in part a textbook of mathematics, a Secondary Section
     may not explain any mathematics.)  The relationship could be a
     matter of historical connection with the subject or with related
     matters, or of legal, commercial, philosophical, ethical or
     political position regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in the
     notice that says that the Document is released under this License.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, whose contents can be viewed and edited directly
     and straightforwardly with generic text editors or (for images
     composed of pixels) generic paint programs or (for drawings) some
     widely available drawing editor, and that is suitable for input to
     text formatters or for automatic translation to a variety of
     formats suitable for input to text formatters.  A copy made in an
     otherwise Transparent file format whose markup has been designed to
     thwart or discourage subsequent modification by readers is not
     Transparent.  A copy that is not "Transparent" is called "Opaque."

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and standard-conforming
     simple HTML designed for human modification.  Opaque formats
     include PostScript, PDF, proprietary formats that can be read and
     edited only by proprietary word processors, SGML or XML for which
     the DTD and/or processing tools are not generally available, and
     the machine-generated HTML produced by some word processors for
     output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow the
     conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies of the Document numbering more than
     100, and the Document's license notice requires Cover Texts, you
     must enclose the copies in covers that carry, clearly and legibly,
     all these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the title
     equally prominent and visible.  You may add other material on the
     covers in addition.  Copying with changes limited to the covers, as
     long as they preserve the title of the Document and satisfy these
     conditions, can be treated as verbatim copying in other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a machine-readable
     Transparent copy along with each Opaque copy, or state in or with
     each Opaque copy a publicly-accessible computer-network location
     containing a complete Transparent copy of the Document, free of
     added material, which the general network-using public has access
     to download anonymously at no charge using public-standard network
     protocols.  If you use the latter option, you must take reasonably
     prudent steps, when you begin distribution of Opaque copies in
     quantity, to ensure that this Transparent copy will remain thus
     accessible at the stated location until at least one year after the
     last time you distribute an Opaque copy (directly or through your
     agents or retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of copies,
     to give them a chance to provide you with an updated version of the
     Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with the
     Modified Version filling the role of the Document, thus licensing
     distribution and modification of the Modified Version to whoever
     possesses a copy of it.  In addition, you must do these things in
     the Modified Version:

     A. Use in the Title Page (and on the covers, if any) a title
     distinct from that of the Document, and from those of previous
     versions (which should, if there were any, be listed in the History
     section of the Document).  You may use the same title as a previous
     version if the original publisher of that version gives permission.
     B. List on the Title Page, as authors, one or more persons or
     entities responsible for authorship of the modifications in the
     Modified Version, together with at least five of the principal
     authors of the Document (all of its principal authors, if it has
     less than five).
     C. State on the Title page the name of the publisher of the
     Modified Version, as the publisher.
     D. Preserve all the copyright notices of the Document.
     E. Add an appropriate copyright notice for your modifications
     adjacent to the other copyright notices.
     F. Include, immediately after the copyright notices, a license
     notice giving the public permission to use the Modified Version
     under the terms of this License, in the form shown in the Addendum
     below.
     G. Preserve in that license notice the full lists of Invariant
     Sections and required Cover Texts given in the Document's license
     notice.
     H. Include an unaltered copy of this License.
     I. Preserve the section entitled "History", and its title, and add
     to it an item stating at least the title, year, new authors, and
     publisher of the Modified Version as given on the Title Page.  If
     there is no section entitled "History" in the Document, create one
     stating the title, year, authors, and publisher of the Document as
     given on its Title Page, then add an item describing the Modified
     Version as stated in the previous sentence.
     J. Preserve the network location, if any, given in the Document for
     public access to a Transparent copy of the Document, and likewise
     the network locations given in the Document for previous versions
     it was based on.  These may be placed in the "History" section.
     You may omit a network location for a work that was published at
     least four years before the Document itself, or if the original
     publisher of the version it refers to gives permission.
     K. In any section entitled "Acknowledgements" or "Dedications",
     preserve the section's title, and preserve in the section all the
     substance and tone of each of the contributor acknowledgements
     and/or dedications given therein.
     L. Preserve all the Invariant Sections of the Document, unaltered
     in their text and in their titles.  Section numbers or the
     equivalent are not considered part of the section titles.
     M. Delete any section entitled "Endorsements."  Such a section may
     not be included in the Modified Version.
     N. Do not retitle any existing section as "Endorsements" or to
     conflict in title with any Invariant Section.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option designate
     some or all of these sections as invariant.  To do this, add their
     titles to the list of Invariant Sections in the Modified Version's
     license notice.  These titles must be distinct from any other
     section titles.

     You may add a section entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties-for example, statements of peer review or that the text has
     been approved by an organization as the authoritative definition of
     a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end of
     the list of Cover Texts in the Modified Version.  Only one passage
     of Front-Cover Text and one of Back-Cover Text may be added by (or
     through arrangements made by) any one entity.  If the Document
     already includes a cover text for the same cover, previously added
     by you or by arrangement made by the same entity you are acting on
     behalf of, you may not add another; but you may replace the old
     one, on explicit permission from the previous publisher that added
     the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination all
     of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections entitled
     "History" in the various original documents, forming one section
     entitled "History"; likewise combine any sections entitled
     "Acknowledgements", and any sections entitled "Dedications."  You
     must delete all sections entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the documents
     in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow this
     License in all other respects regarding verbatim copying of that
     document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of a
     storage or distribution medium, does not as a whole count as a
     Modified Version of the Document, provided no compilation copyright
     is claimed for the compilation.  Such a compilation is called an
     "aggregate", and this License does not apply to the other
     self-contained works thus compiled with the Document, on account of
     their being thus compiled, if they are not themselves derivative
     works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one
     quarter of the entire aggregate, the Document's Cover Texts may be
     placed on covers that surround only the Document within the
     aggregate.  Otherwise they must appear on covers around the whole
     aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License provided that you also include the
     original English version of this License.  In case of a
     disagreement between the translation and the original English
     version of this License, the original English version will prevail.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided for under this License.  Any other
     attempt to copy, modify, sublicense or distribute the Document is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses terminated
     so long as such parties remain in full compliance.

  10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     http://www.gnu.org/copyleft/.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If the
     Document does not specify a version number of this License, you may
     choose any version ever published (not as a draft) by the Free
     Software Foundation.

ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

     Copyright (C)  YEAR  YOUR NAME.
     Permission is granted to copy, distribute and/or modify this document
     under the terms of the GNU Free Documentation License, Version 1.1
     or any later version published by the Free Software Foundation;
     with the Invariant Sections being LIST THEIR TITLES, with the
     Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
     A copy of the license is included in the section entitled "GNU
     Free Documentation License."

   If you have no Invariant Sections, write "with no Invariant Sections"
instead of saying which ones are invariant.  If you have no Front-Cover
Texts, write "no Front-Cover Texts" instead of "Front-Cover Texts being
LIST"; likewise for Back-Cover Texts.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of free
software license, such as the GNU General Public License, to permit
their use in free software.


File: bashdb.info,  Node: Command Index,  Next: General Index,  Prev: GNU Free Documentation License,  Up: Top

Command Index
*************

 [index ]
* Menu:

* !! ('shell'):                          Evaluation/Execution. (line 73)
* ![-]N ('history'):                     History.              (line 40)
* # (a comment):                         Command Syntax.       (line 16)
* alias NAME COMMAND:                    Alias.                (line  6)
* b ('break'):                           Set Breaks.           (line  6)
* backtrace:                             Backtrace.            (line 11)
* break:                                 Set Breaks.           (line  6)
* bt ('backtrace'):                      Backtrace.            (line 11)
* c ('continue'):                        Continue.             (line  6)
* cd [DIRECTORY]:                        Interfacing to the OS.
                                                               (line  6)
* clear:                                 Delete Breaks.        (line 21)
* commands:                              Break Commands.       (line  6)
* condition:                             Conditions.           (line 26)
* continue:                              Continue.             (line  6)
* d ('clear'):                           Delete Breaks.        (line 21)
* de ('delete'):                         Delete Breaks.        (line 43)
* debug:                                 Debug.                (line  6)
* delete:                                Delete Breaks.        (line 43)
* delete display:                        Auto Display.         (line 25)
* dis ('disable'):                       Disabling.            (line 32)
* disable:                               Disabling.            (line 32)
* disable breakpoints:                   Disabling.            (line 32)
* disable display:                       Auto Display.         (line 32)
* display:                               Auto Display.         (line 17)
* do ('down'):                           Selection.            (line 22)
* down:                                  Selection.            (line 22)
* e ('eval'):                            Evaluation/Execution. (line 11)
* edit [LINE-SPECIFICATION]:             Edit.                 (line 27)
* enable:                                Disabling.            (line 39)
* enable breakpoints:                    Disabling.            (line 39)
* enable display:                        Auto Display.         (line 37)
* end:                                   Break Commands.       (line  6)
* eval:                                  Evaluation/Execution. (line 11)
* examine:                               Data.                 (line 38)
* file:                                  File.                 (line 16)
* finish:                                Finish.               (line  6)
* forward:                               Search.               (line  9)
* frame:                                 Selection.            (line 54)
* h ('help'):                            Help.                 (line  9)
* H [START-NUMBER [END-NUMBER]]:         History.              (line 13)
* handle:                                handle.               (line  6)
* history [-][N]:                        History.              (line 40)
* i ('info'):                            Help.                 (line 48)
* info:                                  Help.                 (line 48)
* info args:                             Info.                 (line 12)
* info breakpoints:                      Set Breaks.           (line 49)
* info breakpoints <1>:                  Info.                 (line 13)
* info display:                          Auto Display.         (line 42)
* info display <1>:                      Info.                 (line 15)
* info files:                            Info.                 (line 17)
* info functions:                        Info.                 (line 19)
* info line:                             Info.                 (line 21)
* info program:                          Info.                 (line 23)
* info signals:                          handle.               (line  9)
* info signals <1>:                      Info.                 (line 25)
* info source:                           Info.                 (line 27)
* info stack:                            Info.                 (line 29)
* info terminal:                         Input/Output.         (line 12)
* info terminal <1>:                     Info.                 (line 31)
* info variables:                        Data.                 (line 88)
* info variables <1>:                    Info.                 (line 33)
* k ('kill'):                            Quit.                 (line 39)
* l ('list'):                            List.                 (line 16)
* list:                                  List.                 (line 16)
* n ('next'):                            Next.                 (line  6)
* next:                                  Next.                 (line  6)
* p ('print'):                           Data.                 (line 12)
* print:                                 Data.                 (line  6)
* print <1>:                             Data.                 (line 12)
* pwd:                                   Interfacing to the OS.
                                                               (line 17)
* q ('quit'):                            Quit.                 (line  6)
* quit [EXPRESSION [SUBSHELL-LEVELS]]:   Quit.                 (line  6)
* R ('restart'):                         Starting.             (line 13)
* restart [ARGS]:                        Starting.             (line 13)
* RET (repeat last command):             Command Syntax.       (line 13)
* return:                                Returning.            (line  6)
* reverse-search:                        Search.               (line  6)
* run ('restart'):                       Starting.             (line 13)
* s ('step'):                            Step.                 (line  6)
* search:                                Search.               (line  9)
* set annotate:                          Annotate.             (line  6)
* set args:                              Arguments.            (line 13)
* set autoeval [ on | 1 | off | 0 ]:     Autoeval.             (line  6)
* set autolist [ on | 1 | off | 0 ]:     Autolist.             (line  6)
* set basename:                          Basename.             (line  6)
* set debugger:                          Debugger.             (line  6)
* set editing:                           Editing.              (line 16)
* set history save:                      History.              (line 55)
* set history size:                      History.              (line 64)
* set linetrace:                         Line Tracing.         (line 15)
* set listsize:                          List.                 (line 47)
* set logging:                           Logging.              (line 10)
* set prompt:                            Prompt.               (line 29)
* set showcommand:                       Command Display.      (line 33)
* set trace-commands:                    Command-Tracing.      (line 11)
* shell ('shell'):                       Evaluation/Execution. (line 81)
* show args:                             Arguments.            (line 20)
* show autoeval:                         Autoeval.             (line 26)
* show copying:                          Show.                 (line 28)
* show editing:                          Editing.              (line 23)
* show history:                          History.              (line 69)
* show listsize:                         List.                 (line 51)
* show prompt:                           Prompt.               (line 36)
* show version:                          Show.                 (line 18)
* show warranty:                         Show.                 (line 48)
* shows:                                 History.              (line 75)
* signal:                                signal.               (line  6)
* silent:                                Break Commands.       (line 33)
* skip:                                  Skip.                 (line  6)
* source:                                Command Files.        (line 37)
* step:                                  Step.                 (line  6)
* tbreak:                                Set Breaks.           (line 43)
* tty:                                   Input/Output.         (line 16)
* unalias NAME COMMAND:                  Alias.                (line  9)
* undisplay DNUMS...:                    Auto Display.         (line 25)
* up [N]:                                Selection.            (line 11)
* V ('info variables'):                  Data.                 (line 88)
* watch:                                 Set Watchpoints.      (line 17)
* where:                                 Backtrace.            (line 24)
* x ('examine'):                         Data.                 (line 38)


File: bashdb.info,  Node: General Index,  Prev: Command Index,  Up: Top

General Index
*************

 [index ]
* Menu:

* '$PS4':                                Interactive Line Tracing Session.
                                                               (line  6)
* '$_' and 'info breakpoints':           Set Breaks.           (line 49)
* '--annotate':                          Options for the bashdb script.
                                                               (line 18)
* '--basename':                          Options for the bashdb script.
                                                               (line 29)
* '--command':                           Options for the bashdb script.
                                                               (line 26)
* '--eval-command' CMDFILE:              Options for the bashdb script.
                                                               (line 53)
* '--help':                              Options for the bashdb script.
                                                               (line 10)
* '--library':                           Options for the bashdb script.
                                                               (line 56)
* '--no-init':                           Options for the bashdb script.
                                                               (line 33)
* '--nx':                                Options for the bashdb script.
                                                               (line 33)
* '--quiet':                             Options for the bashdb script.
                                                               (line 39)
* '--tempdir':                           Options for the bashdb script.
                                                               (line 65)
* '--terminal':                          Options for the bashdb script.
                                                               (line 43)
* '--tty':                               Options for the bashdb script.
                                                               (line 43)
* '-A':                                  Options for the bashdb script.
                                                               (line 18)
* '-B':                                  Options for the bashdb script.
                                                               (line 29)
* '-c':                                  Options for the bashdb script.
                                                               (line 26)
* '-h':                                  Options for the bashdb script.
                                                               (line 10)
* '-L':                                  Options for the bashdb script.
                                                               (line 56)
* '-n':                                  Options for the bashdb script.
                                                               (line 33)
* '-q':                                  Options for the bashdb script.
                                                               (line 39)
* '-t':                                  Options for the bashdb script.
                                                               (line 43)
* '-T':                                  Options for the bashdb script.
                                                               (line 65)
* '-V':                                  Options for the bashdb script.
                                                               (line 14)
* '-x':                                  Options for the bashdb script.
                                                               (line 53)
* '.bashdbinit':                         Command Files.        (line 11)
* arguments (to your script):            Arguments.            (line  6)
* automatic display:                     Auto Display.         (line  6)
* backtraces:                            Backtrace.            (line  6)
* BASH debugger bugs, reporting:         Bug Reporting.        (line  6)
* 'bashdb.ini':                          Command Files.        (line 11)
* breakpoint conditions:                 Conditions.           (line  6)
* breakpoint numbers:                    Breakpoints.          (line 27)
* breakpoint on variable modification:   Breakpoints.          (line 15)
* breakpoints:                           Breakpoints.          (line  6)
* bug criteria:                          Bug Criteria.         (line  6)
* bug reports:                           Bug Reporting.        (line  6)
* bugs:                                  BASH Debugger Bugs.   (line  6)
* call stack:                            Stack.                (line  9)
* change working directory:              Interfacing to the OS.
                                                               (line  6)
* clearing breakpoints, watchpoints:     Delete Breaks.        (line  6)
* command files:                         Command Files.        (line  6)
* command line editing:                  Editing.              (line  6)
* command scripts, debugging:            Command-Tracing.      (line 11)
* comment:                               Command Syntax.       (line 16)
* conditional breakpoints:               Conditions.           (line  6)
* continuing:                            Resuming Execution.   (line 13)
* controlling terminal:                  Input/Output.         (line 16)
* crash of debugger:                     Bug Criteria.         (line  9)
* current stack frame:                   Selection.            (line 54)
* debugger crash:                        Bug Criteria.         (line  9)
* delete breakpoints:                    Delete Breaks.        (line 43)
* deleting breakpoints, watchpoints:     Delete Breaks.        (line  6)
* display of expressions:                Auto Display.         (line  6)
* editing:                               Editing.              (line 16)
* error on valid input:                  Bug Criteria.         (line 12)
* examining data:                        Data.                 (line  6)
* fatal signal:                          Bug Criteria.         (line  9)
* fatal signals:                         Signals.              (line 42)
* frame number:                          Frames.               (line 21)
* frame, definition:                     Frames.               (line  6)
* handling signals:                      Signals.              (line 54)
* history save:                          History.              (line 55)
* history size:                          History.              (line 64)
* I/O:                                   Input/Output.         (line  6)
* init file:                             Command Files.        (line 11)
* init file name:                        Command Files.        (line 28)
* initial frame:                         Frames.               (line 12)
* innermost frame:                       Frames.               (line 12)
* interrupt:                             Quitting the BASH debugger.
                                                               (line  6)
* invalid input:                         Bug Criteria.         (line 16)
* latest breakpoint:                     Set Breaks.           (line  6)
* linespec:                              List.                 (line 60)
* nested shell:                          Evaluation/Execution. (line 81)
* numbers for breakpoints:               Breakpoints.          (line 27)
* numbers for watchpoints:               Breakpoints.          (line 34)
* one-time breakpoints:                  Conditions.           (line 17)
* online documentation:                  Help.                 (line  6)
* outermost frame:                       Frames.               (line 12)
* print working directory:               Interfacing to the OS.
                                                               (line 17)
* printing data:                         Data.                 (line  6)
* prompt:                                Prompt.               (line  6)
* readline:                              Editing.              (line  6)
* redirection:                           Input/Output.         (line  6)
* repeating next/step commands:          Command Syntax.       (line 13)
* reporting bugs:                        BASH Debugger Bugs.   (line  6)
* resuming execution:                    Resuming Execution.   (line 13)
* returning from a function, sourced file or subshell: Returning.
                                                               (line  6)
* running:                               Starting.             (line  6)
* searching:                             Search.               (line  6)
* selected frame:                        Stack.                (line 14)
* setting watchpoints:                   Set Watchpoints.      (line  6)
* shell escape:                          Evaluation/Execution. (line 73)
* signals:                               Signals.              (line  6)
* stack frame:                           Frames.               (line  6)
* stack traces:                          Backtrace.            (line  6)
* starting:                              Starting.             (line  6)
* stepping:                              Resuming Execution.   (line 13)
* terminal:                              Input/Output.         (line  6)
* tracebacks:                            Backtrace.            (line  6)
* tracing debugger commands:             Command-Tracing.      (line  6)
* version number:                        Show.                 (line 18)
* watchpoints:                           Breakpoints.          (line 15)
* watchpoints numbers:                   Breakpoints.          (line 34)



Tag Table:
Node: Top776
Node: Summary1855
Node: Sample Session3142
Ref: Sample Session-Footnote-112148
Node: Interactive Line Tracing Session12331
Ref: PS412505
Node: Invocation18855
Node: Starting the BASH debugger19842
Ref: Starting the BASH debugger-Footnote-124012
Node: Options for the bashdb script24222
Node: Quitting the BASH debugger26856
Node: Calling from Program27515
Node: Debugging a Running Shell Script29101
Node: Program-Controlled Line Tracing33836
Node: Running34634
Node: Starting35111
Node: Command Files36322
Ref: Command Files-Footnote-138113
Ref: Command Files-Footnote-238258
Node: Arguments38367
Node: Input/Output39263
Node: Script/Debugger Interaction40764
Node: Debugger Command Reference43114
Node: Command Syntax44550
Node: Help45359
Node: Quit48695
Node: Stopping50836
Node: Breakpoints51925
Node: Set Breaks54269
Node: Set Watchpoints58280
Node: Break Commands59615
Node: Delete Breaks62252
Node: Disabling64460
Node: Conditions66798
Node: Resuming Execution68625
Node: Step70020
Node: Next71344
Node: Finish71944
Node: Skip72524
Node: Continue72952
Node: Debug74172
Node: Returning74735
Node: Signals75637
Node: handle78526
Node: signal79843
Node: Stack80197
Node: Frames81560
Node: Backtrace82882
Node: Selection85190
Node: List88174
Node: Edit91425
Node: Search92600
Node: Data93631
Node: Auto Display97708
Node: Evaluation/Execution99676
Node: Interfacing to the OS104607
Node: Information and Settings105385
Node: Info106125
Node: Show107334
Node: Controlling bashdb109178
Node: Alias110455
Node: Annotate110742
Node: Autoeval111394
Node: Autolist112615
Node: Basename112914
Node: Debugger113520
Node: File113997
Node: Line Tracing114958
Node: Logging115719
Node: Prompt116735
Node: Editing118491
Node: Command-Tracing119405
Node: Command Display120126
Node: History122567
Node: Command Completion125772
Node: BASH Debugger Bugs126447
Node: Bug Criteria127235
Node: Bug Reporting128180
Node: History and Acknowledgments134209
Node: Copying138972
Node: GNU Free Documentation License158193
Node: Command Index177818
Node: General Index186871

End Tag Table
